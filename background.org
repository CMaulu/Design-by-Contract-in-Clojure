#+TITLE:     Clojure DbC: Background
#+AUTHOR:    Giles Chamberlin
#+OPTIONS:   H:2 num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+LaTeX_CLASS_OPTIONS: [a4paper, 12pt] 
#+LATEX_HEADER: \usepackage{parskip} \usepackage{times} \usepackage{listings} \usepackage{cite}
#+LATEX_HEADER: \usepackage{hyperref}

\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black}



* A background to Design by Contract


There is a long history \cite{historical} to the use of assertions to
improve program reliability.  Originally introduced to support formal
reasoning about the state of the program, there has been significant
uptake amongst practising software engineers beginning with Parnas'
description of software module specification \cite{Parnas}.  The
current state of the art is such that assertions are frequently used
for pragmatic reasons but rarely to formally prove the program
\cite{Hoare}. 

In this section we consider the use of run time assertion checking
systems in a number of languages.  Our intent is to use this
discussion to ascertain the important features of such a system which
may then be used as the basis of the requirements of a similar system
for Clojure.


** Eiffel

Meyer's book "Object Oriented Software Construction" \cite{OOSC}
introduced Design by Contract to much of the software engineering
community.  In the book, Meyer lays out his views of how to develop
robust software and in the process introduces a new object oriented
language which embodies those design principles. One of the key concepts
was the use of pre and post conditions to provide a contract between
the caller and provider of a method.  In the event of contract
violation blame could be assigned  depending upon which condition was
violated.  

Inheritance and the Liskov Substitution Principle (LSP) \cite{lsp} are
supported through the respective strengthening and weakening of pre
and post conditions in derived classes.

Eiffel contracts are implemented in terms of assertions, similar to
those found in the C family of languages. In practice Eiffel
assertions are generally restricted to simple checks on field and
parameter values.  Function calls are permitted though Meyer argues
(p402) that such functions should be kept simple and "beyond
reproach".

With Meyer's strongly object oriented approach, contracts are enforced
when calling the public methods of an object. Calls internal to an
object do not invoke the contracts or trigger invariant checks.

In line with Parnas' assertion that contracts should be readily
available to the developer, Meyer provides a tool which generates a
short form of his class descriptions; essentially an interface
specification.  This short form includes the pre and post conditions.



** JML

JML \cite{jml} provides a Design by Contract framework for Java.  Much
of the functionality is similar to that introduced in Eiffel: pre and
post conditions are provided for class methods and the LSP is
supported through the respective strengthening and weakening of those
pre and post conditions.

JML is written in terms of JML annotations embedded in the comments of
the Java program.  These comments are then processed by =jmlc= which
generates a wrapper class to enforce the contract and delegate the
implementation to the native java code.  The use of annotated comments
simplifies the implementation of =jmlc=: it just has to pre-process the
annotations and generate legal java which is then compiled as usual.
Unfortunately it has the disadvantage that the usual productivity
tools associated with a modern development environment: syntax
highlighting, auto-completion etc are no longer available. 

An unusual aspect of JML, in contrast to Eiffel, is its support for
model based specification. An abstract model of the system is
constructed in the JML annotations and its representation checked
against that of the underlying implementation. Data, albeit meta-data,
may be modified in a contract. This is in contrast to the assertion
mechanisms of the C family of languages where assertions should never
have side effects.  The intent is to provide a meta-data model of the
underlying implementation.  Contract conditions may then adjust this
meta-data model to track what should be happening in the
implementation.

\textit{TODO: I would like to spend some more time investigating the
similarities and differences between Design by Contract and Larch's
model based specifications.}

# discussion of side effects in pre on #clojure: use of print
# statements for debugging ...




* Contracts for higher order functions

Although the absence of high order contracts has been picked up by the
functional community, it is also of significance in the procedural and
object oriented communities.  Even in C, function pointers can be passed so it
could be advantageous to attache a contract to those functions.  In OO
paradigms, patterns such as the Command Object \cite{GoF} allow a
closure to be passed to a method for later processing; again a
candidate for high order contract checking.


* Racket

Previously known as PLT Scheme, Racket has taken on the idea of
contracts. Contracts in Racket are separated from the function
definition in a module exports section \cite{racket}. This allows
contracts to be enforced only at module boundaries.  Calls to a
function within the module do not undergo contract checking.  This
follows the premise of Eiffel (p 366).


introduces the concept of =any= and =any/c=.  Can be used to state that any
integer can be returned etc. 


From \cite{racket}: "Contracts are either simple predicates or function
contracts.  Function contracts, in turn, consist of a pair of
contracts [...] one for the domain of the function and one for the
range of the function."

Findler and Felleisen introduce the idea that high order contracts
cannot be enforced until some function consumes or produces only first
order values.

Contract definitions in terms of range and domain rather than predicates.

Separation of contracts on structures from contracts on functions.


# High order contracts described in
# file:./papers/contracts-as-projections.pdf



* Clojure

Clojure \cite{clojure} is a Lisp dialect running on the Java Virtual Machine (JVM).
Primarily a functional language, Clojure uses Software Transactional
Memory (STM) to provide thread safe state changes. As with
other Lisps, a powerful macro system is present.  This allows Clojure
code to be treated as data.  Whilst the deep internals of Clojure are
written in Java, the majority of the language is written in terms of
itself.  For example =defn=, the symbol usually used to introduce a
function definition, is written in terms of =fn=.

A typical use of =defn= would be:

#+srcname:unchecked-java-sqrt
#+begin_src clojure  
  (defn unchecked-java-sqrt
    "Return the square root of n, calling the underlying 
     Java implementation"
    [n]
    (Math/sqrt n))
#+end_src

Anonymous functions may be introduced with =fn=.  

#+begin_src clojure
(fn [n] (+ 3 n))
#+end_src


=fn= itself, the core of a function definition, provides support for
condition checking through meta data.   Since Clojure 1.1 =fn= is
defined \cite{clojure.fn} as:


#+begin_src clojure
(fn name? [params* ] condition-map? exprs*)
(fn name? ([params* ] condition-map? exprs*)+)
#+end_src


Where the optional condition-map parameter may contain keys for pre
and post conditions associated with a vector of assertion expressions.


#+begin_example
{:pre [pre-expr*]
 :post [post-expr*]}
#+end_example

This provides basic condition checking, allowing us to define a new
version of =java-sqrt=


#+srcname: checked-java-sqrt
#+begin_src clojure
  (defn checked-java-sqrt 
    "Precondition checks prior to calling underlying function"
    [n]
    {:pre [(number? n) (>= n 0)]}
    (Math/sqrt n))
#+end_src


#+results:
| function | user/checked-java-sqrt |

Should the pre-condition be violated, a Java =AssertionError=
exception will be thrown which can be handled in Clojure in the normal
manner:


#+begin_src clojure 
(try (print (checked-java-sqrt -1))
       (catch AssertionError e
         (.getMessage e)))
#+end_src


Will return:

#+results:
: Assert failed: (>= n 0)


#+srcname: contracts
#+begin_src clojure :tangle hello.clj :exports none :noweb yes
  <<unchecked-java-sqrt>>

  <<checked-java-sqrt>>
#+end_src


** Anatomy of a clojure precondition

#+begin_src clojure
 (macroexpand '(defn checked-java-sqrt 
    "Precondition checks prior to calling underlying function"
    [n]
    {:pre [(number? n) (>= n 0)]}
    (Math/sqrt n))) 
#+end_src

Macro expansion, prior to compilation, wraps the body of the =defn= in
assertions validating the pre and post conditions.  It is this
augmented body which is compiled to form the function. 

Omitting meta data, macro expansion of =checked-java-sqrt= yields:
#+begin_src clojure
(fn* checked-java-sqrt 
     ([n]
	(clojure.core/assert (number? n))
	(clojure.core/assert (>= n 0))
	(Math/sqrt n))
#+end_src
The demotion of the conditions to generalised assertions loses the
ability to extract the conditions for use in Eiffel style short form
descriptions.




** Mutable data

Clojure provides support for mutable data through the use of
transactional reference =ref='s.  Modifications to the data must be
wrapped in a transaction and may be protected by a validator
function.


\bibliographystyle{plain}
\bibliography{dbc}
