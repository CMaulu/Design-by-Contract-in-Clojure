#+title:     Design by Contract in Clojure
#+AUTHOR:    Giles Chamberlin
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+LaTeX_CLASS_OPTIONS: [a4paper, 12pt] 
#+LATEX_HEADER: \usepackage{parskip} \usepackage{fourier} \usepackage{minted} \usepackage{cite}
#+LATEX_HEADER: \usepackage{hyperref} \usepackage{stmaryrd} \usepackage{tikz}

# stmaryrd used for \rightslice character used in Hinze paper.


# upquote package is used to get proper back quote behaviour in code
# listings.  Means we can't change from Computer Modern for our tt font

#+LaTeX_HEADER: \usepackage{upquote} \usemintedstyle{bw} 

\renewcommand\listoflistingscaption{Program listings}


# If we set the twoside option to article then the following will
# cause each section to appear on an odd numbered page.
# Ignore this though as requirements are to print single sided.
# \let\stdsection\section  
# \def\section{\cleardoublepage\stdsection}  

# Start each section on a new page
\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}


\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black,
    pdfauthor=Giles Chamberlin,
    pdfsubject=Submission for M.Sc. in Software Engineering
    pdftitle=Design by Contract in Conjure
}




#+begin_src sh :exports none
  BIBINPUTS=/Users/grc/dissertation/:$BIBINPUTS
  export BIBINPUTS
#+end_src



\begin{abstract}
What hath I wrought?
\end{abstract}

The author confirms that this dissertation does not contain material
previously submitted for another degree or academic award; and that the
work presented here is the author's own, except where otherwise
stated.

\pagebreak
[TABLE-OF-CONTENTS]

\listoflistings
\pagebreak
* Introduction

To Be Completed


* A background to Design by Contract


There is a long history \cite{historical} behind the use of assertions
to improve program reliability.  Originally introduced to support
formal reasoning about the state of the program, there has been
significant uptake amongst practising software engineers beginning
with Parnas' description of software module specification
\cite{Parnas}.  The current state of the art is such that assertions
are frequently used pragmatically, to verify assumed state, but rarely
to provide formal proof of the correctness of the program \cite{Hoare}.

In this section we consider the use of run time assertion checking
systems in a number of programming languages.  Our intent is to use this
discussion to ascertain the important features of such a system which
may then be used as the basis for the requirements of a system
implemented in Clojure.


** Eiffel

Meyer's book "Object Oriented Software Construction" \cite{oosc}
introduced the term "Design by Contract" to much of the software
engineering community.  In his book, Meyer lays out his views of how
to develop robust software and in the process introduces a new object
oriented language, Eiffel, which embodies those design principles. One
of the key concepts is the use of pre and post conditions to provide a
contract between the caller and provider of a method.  In the event of
contract violation blame is then assigned depending upon which
condition was violated.

Inheritance and the Liskov Substitution Principle (LSP) \cite{lsp} are
supported through the respective weakening and strengthening of pre
and post conditions in derived classes. A derived method may require
no more, and promise no less, than its parent. 

Eiffel contracts are implemented in terms of assertions, similar to
those found in the C family of languages. In practice Eiffel
assertions are generally restricted to simple checks on field and
parameter values.  Function calls are permitted though Meyer argues
\cite[p.\ 402]{oosc} that such functions should be kept simple and
"beyond reproach".  Practically speaking this means that significant
side effects must be avoided.  Significant? The practice of adding
debug print statements is wide spread, particular in the case of a
failed assertion.

With Meyer's strongly object oriented approach, contracts are enforced
when calling the public methods of an object. Calls internal to an
object neither invoke the contracts nor trigger invariant checks.

In line with Parnas' assertion that contracts should be readily
available to the developer, Meyer provides a tool which generates a
short form of his class descriptions; essentially an interface
specification.  This short form includes the pre and post conditions.



** JML

JML \cite{jml} provides a Design by Contract framework for Java.  Much
of the functionality is similar to that introduced in Eiffel: pre and
post conditions are provided for class methods and inheritance is
supported through the respective  weakening and strengthening of those
pre and post conditions. The exact nature of the refinement of pre 
and post conditions differs from that in Eiffel \cite{toth10}.  We
discuss this in section  \ref{meta}.

JML is written in terms of annotations embedded in the comments of the
Java program \cite{jmlc}.  These comments are then processed by =jmlc=
which generates a wrapper class to enforce the contract and delegates
the implementation to the native java code.  The use of annotated
comments simplifies the implementation of =jmlc=: it just has to
pre-process the annotations and generate legal java which is then
compiled as usual.  Unfortunately it has the disadvantage that the
usual productivity tools associated with a modern development
environment: syntax highlighting, auto-completion etc. are no longer
available. To the tool, the JML markup appears to be simply comments
and is processed as such.

A distinctive aspect of JML, in contrast to Eiffel, is its support for
model based specification based on the work in Larch
\cite{Guttag:1993:LLT:151155}. An abstract model of the system is
constructed in the JML annotations and its representation checked
against that of the underlying implementation. Data, albeit meta-data,
may be modified in a contract. This is in contrast to the assertion
mechanisms of the C family of languages where assertions should never
have significant side effects.  The intent is to provide a meta-data
model of the underlying implementation.  Contract conditions may then
adjust this meta-data model to track what should be happening in the
implementation.





** Microsoft CLR

An interesting devlopment over the last few years has been the rise of
the virtual machine as a platform on which to build programming
languages.  Arguably the two dominant players are Microsoft's Common
Language Runtime (CLR) and the Java Virtual Machine (JVM).

Microsoft has implemented a version of Eiffel's contract checking in
the CLR \cite{msft-contract},\cite{ECL}.  Interestingly this provides
both run time and static checking.  Perhaps because this feature in
not enabled by default in the Visual Studio IDE, usage appears to be
very low.

** Contracts in functional languages
The simple parameter and return value checking that follows from
Parnas' work has proved useful in the procedural world.  Its utility
is severely reduced in functional programming paradigms where
functions are passed around as first class objects.  It is no longer
possible to simply examine the arguments to a function at call time to
know if they satisfy the pre condition.


Although the absence of high order contracts has been noted by the
functional community, it is also of significance in the procedural and
object oriented communities.  Even in C, function pointers can be
passed so it could be advantageous to attach a contract to those
functions.  In object oriented paradigms, patterns such as the Command
Object \cite{gof} allow a closure to be passed to a method for later
processing; again a candidate for high order contract checking.


Racket, previously known as PLT Scheme, has taken on the idea of
contracts. Contracts in Racket are separated from the function 
definition in a module exports section \cite{racket}. This allows
contracts to be enforced only at module boundaries.  Calls to a
function within the module do not undergo contract checking.  This
follows the premise of Eiffel \cite[p.\ 366]{oosc}.


# introduces the concept of =any= and =any/c=.  Can be used to state
# that any integer can be returned etc.

The Racket implementation is based on the work of Findler and
Felleisen \cite{hof} who state that: "Contracts are either simple
predicates or function contracts.  Function contracts, in turn,
consist of a pair of contracts [\ldots] one for the domain of the
function and one for the range of the function."
It is this recursive approach to contracts which allows the use of
high order functions --- high order contracts cannot be enforced until
some function consumes or produces only first order values.

Central to their implementation of contracts for high order functions
is the meta function, =wrap= which wraps the underlying function
implementation.  If the contract is a simple predicate, it is
evaluated. Higher order contracts consist of two terms: a pre- and
post- condition, each of which in turn may be first or higher order.
For these high order contracts, =wrap= is recursively applied to the
high order term.

\cite{hof} also investigates blame assignment.  Whilst knowing that a
program is faulty is helpful, knowing where the fault lies is more
useful.  \{hof} introduces the concept of positive and negative
positions in the =wrap= function.  Initially these are applied to
caller and called function. Should a first order contract fail the
positive location is blamed.  Higher order contracts have the positive
and negative locations swapped before the recursive application of
=wrap=.


# High order contracts described in
# file:./papers/contracts-as-projections.pdf


Hinze et al.\cite{citeulike:661450} extend the work of Findler and
Felleisen, introducing a Domain Specific Language (DSL) to support the
description and composition of contracts.  Again a focus of this work
is on refining the blame assignment in the event of a contract failure.
Whilst is helpful to know of the existence of a bug in your program,
knowledge as to where in the program the bug exists is even more
valuable.  Findler and Felleisen track at most two locations for blame
assignment. When contracts are being applied to high order functions,
this necessitates discarding dependent contract location data and
replacing with the current contract's location data.  Hinze et al.
provide a pair of stacks of locations.  For a first order function
this simplifies to the Findler and Felleisen model, but carries
additional information for higher order functions.



* A brief introduction to Clojure

Clojure, first introduced in 2007, is according to its inventor:

\begin{quote}
\begin{itemize}
\item A Lisp

\item for functional programming

\item symbiotic with an established platform

\item designed for concurrency\cite{rationale}
\end{itemize}
\end{quote}

I chose to use Clojure as the platform for my investigation of Design
by Contract in part because of Lisp's flexibility for such experiments
and in part through a desire to get to know Clojure better: my
professional work developing video conferencing infrastructure was
repeatedly showing the need for multi-core concurrency and the ability
to integrate easily with a large body of sophisticated and specialised
libraries. Being built on the Java Virtual Machine (JVM), Clojure has
outstanding access to libraries and is designed with concurrency in
mind.

Clojure is a member of the Lisp family of languages whose common
ancestor was invented by John McCarthy in the late 1950's \cite{}.
Various flavours of Lisp have hovered around, but never quite broken
into, the mainstream software development world. Lisps have played a
significant role in research into areas such as artificial
intelligence \cite{paip} and object oriented programming
\cite{kiczales} where the simplicity of the core language
\cite{roots-of-lisp} combined with its colonising approach to new
paradigms makes it a powerful vehicle for experimentation.


** Anatomy of a Clojure program
 
Like other Lisps, Clojure programs are built from sexprs (symbolic
expressions) where a sexpr is either an atom, e.g. the integer =42=,
or an expression of the form 
\begin{texttt}(x\space.\space{}y)\end{texttt}  
where =x= and =y= are themselves sexprs.  The notation 
\begin{texttt}(x\space.\space{}y)\end{texttt}  
denotes a cons cell, terminology derived from the lisp function used
to construct it.  It represents an ordered pair of values and is
typically used to build linked lists.  In such a case the second value
(known as the =cdr= of the cell) points to the next cons cell.  Proper
lists are terminated when the =cdr= is nil. Figure \ref{fig:cons}
shows the construction of a proper list 
\begin{texttt}((x\space.\space{}y)\space{}nil)\end{texttt} 


# cons cell diagram
\begin{figure}
\label{fig:cons}
\centering
\usetikzlibrary[arrows]
\begin{tikzpicture}
      \node (xcar) at ( 0,2) [shape=rectangle,draw, minimum size = 10mm] {};
      \node (xvalue) at ( 0, 0) {x};
      \node (xcdr) at ( 10mm, 2)  [shape=rectangle,draw, minimum size=10mm] {};
      
      \node (ycar) at (40mm, 2) [shape=rectangle,draw, minimum size = 10mm] {};
      \node (ycdr) at (50mm, 2) [shape=rectangle,draw, minimum size = 10mm] {};
      \node (yvalue) at (40mm, 0) {y};

      \node (nil) at (80mm, 2) {nil};

      \draw[ *->] (xcar.center) -- (xvalue);
      \draw[ *->] (xcdr.center) -- (ycar);
      \draw[*->] (ycar.center) -- (yvalue);
      \draw[*->] (ycdr.center) -- (nil);
\end{tikzpicture}

\caption{Lisp cons cells and lists}
\end{figure}

Since lists form the basic building block of the language, and are
thus very common, a short hand notation is provided. The proper list
\begin{texttt}((x\space.\space{}y)\space{}nil)\end{texttt} 
is usually represented as 
\begin{texttt}(x\space{}y)\end{texttt}.

Sexprs which may be evaluated are known as forms.  With a few
exceptions described later, the processing rules assume that the first
element of the form is a function and apply that function to the
subsequent elements of the form.  Lisps follow eager evaluation of
function arguments, so should any of the later elements themselves be
a form, they too will be evaluated before being passed to the original
function:

#+begin_src clojure
(+ 1 2 (* 2 3))
9
#+end_src 


The processing exceptions mentioned above are known as "special
forms". There are a number of these which do not obey the usual
processing rules.  Consider For example an =if= statement:

#+begin_src clojure
  (if (< 1 2)                         ; 1
    (print "Normal maths applies")    ; 2
    (print "Strange maths applies"))  ; 3
#+end_src

The intent is that, if the test on the first line is true execute line
2, otherwise line 3.  Following the rules described above we need to
evaluate all the arguments to =if= before passing them to the form.
This would result in two, contradictory, messages being printed.  The
lack of support for lazy evaluation \cite{lazy} in Clojure means that
we to make =if= an exception to the normal processing rues: a special
form.


** Other data structures

Classical Lisps use lists, =(...)= as their data structure of
choice.  Clojure extends the code-as-data system to include maps and
vectors.  This means that the reader, that part of the system
responsible for parsing the input, prior to evaluation, has innate
knowledge of these structures, allowing them to be used in the macro
system described later.

Maps, similar to Python's dictionaries, are a sequence of key value
pairs.  

#+begin_src clojure
(def map-example {"one" 1 "two" 2})
#+end_src

As a map is also a valid function, map lookup may be performed using
the key:

#+begin_src clojure
(map-example "one")
 > 1
#+end_src

Clojure also supports vectors as a first class data structure, indeed
it is the data structure of choice in many cases such as passing
arguments to a function.  Denoted by =[...]=, they too are a valid
function:

#+begin_src clojure
(def vector-example [10 20 30 40])
(vector-example  2)
> 30
#+end_src

** Macros


All Clojure programs consist of lists of sexprs.  This homoiconicity
of Lisps, the fact that the program text itself forms a valid Lisp
data structure, is central to the power of Lisp's - and Clojure's -
macro system. The full power of the language is available to
manipulate the data structures that form the program
text. Unfortunately the use of the name "macro" for this aspect of the
language can cause confusion with the well known, and usually
disliked, C macro system.  It is worth emphasising that, whilst C
macros provide basic textual substitution in a pre-processor, a Lisp
macro is operating not on the text but on a data structure created
from the parsed text.  A better comparison would be that Lisp macros
provide a more powerful, and readable, version of C++ template meta
programming.


TODO This was just dropped in

Lisp's macros should not be considered in the same vein as the C
family =#define=.  Whilst C's macros use a simple pre processor to
perform textual substitution, Lisp macros have access to the entire
Lisp language to perform manipulations.  Macro are run and generate
code at macro expansion time.  That code and any other regular code is
then executed at run time.  

At their simplest macros make use of the backquote special form.  In a
similar manner to the =quote= special form, the body of a backquote
expression is emitted verbatim.  Unlike the =quote= syntax, individual
elements of the body can be executed by preceding with a =~=.  The
following macro emits code to sum the macro arguments:

#+begin_src clojure
(defmacro pointless-summation [a b]
  `(+ ~a ~b))

(pointless-summation 3 4)
#+end_src

The generated code can be examined using =macroexpand= which reveals
that the above expands to:

#+begin_src clojure
(clojure.core/+ 3 4)
#+end_src

This is the code which will be executed at run time. A full
explanation of macros is beyond the scope of this dissertation,
\cite{Seibel} is recommended as a starting point.


The Lisp macro system in turn allows much of Lisp to be written in
terms of itself; there is a very restricted set of special forms which
provide functionality which cannot be obtained by following the
standard evaluation rules.  This is the case with Clojure; whilst the
deep internals of the language are written in Java, the majority of
the language is written in terms of Clojure itself.  For example
anonymous functions may be introduced with =fn=.

#+begin_src clojure
(fn [n] (+ 3 n))
#+end_src

=defn=, \label{defn} the symbol usually used to introduce a named function
definition, is written in terms of =fn=: =(def name (fn [params* ]
exprs*))=, where =def= is a special form which defines a symbol, an
association of a name and a =var=.

A typical use of =defn= would be:

#+srcname:unchecked-java-sqrt
#+begin_src clojure  
(defn unchecked-java-sqrt
  "Return the square root of n, calling the underlying 
   Java implementation"
  [n]
  (Math/sqrt n))
#+end_src

The use of macros to build layers of functionality on top of the core
implementation, the ability to treat the program as data, makes Lisp
an attractive language in which to experiment when we wish to modify
the behaviour of the language itself.

=fn= itself, the core of a function definition, provides support for
simple condition checking through meta data.   Since Clojure 1.1 =fn= is
declared \cite{clojure.fn} as:


#+begin_src clojure
(fn name? [params* ] condition-map? exprs*)
(fn name? ([params* ] condition-map? exprs*)+)
#+end_src


Where the optional =condition-map= parameter may contain keys for pre
and post conditions associated with a vector of assertion expressions.


#+begin_example
{:pre [pre-expr*]
 :post [post-expr*]}
#+end_example

This provides basic condition checking, allowing us to define a new
version of =java-sqrt=


#+srcname: checked-java-sqrt
#+begin_src clojure
(defn checked-java-sqrt 
  "Pre Condition checks prior to calling underlying function"
  [n]
  {:pre [(number? n) (>= n 0)]}
  (Math/sqrt n))
#+end_src


Should the pre condition be violated, a Java =AssertionError=
exception will be thrown which can be handled in Clojure in the normal
manner:


#+begin_src clojure 
(try (print (checked-java-sqrt -1))
     (catch AssertionError e
       (.getMessage e)))
#+end_src


Will result in:

#+results:
: Assert failed: (>= n 0)


#+srcname: contracts
#+begin_src clojure :tangle hello.clj :exports none :noweb yes
  <<unchecked-java-sqrt>>

  <<checked-java-sqrt>>
#+end_src




*** Clojure's built in pre and post conditions

The usual way of introducing a function into a Clojure environment,
=defn= is a macro which can accept pre and post conditions..
#+begin_src clojure :exports none
(macroexpand '(defn checked-java-sqrt 
                "Pre Condition checks prior to calling underlying function"
                [n]
                {:pre [(number? n) (>= n 0)]}
                (Math/sqrt n))) 
#+end_src

Macro expansion, prior to compilation, wraps the body of the =defn= in
assertions validating the pre and post conditions.  It is this
augmented body which is compiled to form the function. 

Omitting meta data, macro expansion of =checked-java-sqrt= yields:
#+begin_src clojure
(fn* checked-java-sqrt 
     ([n]
	(clojure.core/assert (number? n))
	(clojure.core/assert (>= n 0))
	(Math/sqrt n)))
#+end_src
The demotion of the conditions to generalised assertions loses the
ability to extract the conditions for use in Eiffel style short form
descriptions. Pre or post condition violation can be inferred from
which assertion fails and blame assigned through inspection of the
call stack obtained via =getStackTrace= in the case of pre condition
failure. Though usually robust, it is possible for the JVM to omit
stack frames in order to optimise execution so a violating caller may
not appear in the list of blame candidates.


*** Mutable data

State, mutable data, is at odds with the "designed for concurrency"
goal \cite{rationale} of Clojure.  If two methods use and can
modify the same piece of data then to allow the two methods to run
concurrently requires some form of concurrency control.  Typically
this concurrency control takes the form of a locking strategy: before
modifying mutable data the method must acquire a lock, releasing it
when the operation is complete.  Improper locking strategies --- method
1 acquires lock A, then lock B, method 2 B then A --- can result in
deadlock.  More fundamentally, lock based strategies are not
composable \cite{Harris}: 
\begin{quote} 
Perhaps the most fundamental objection [...] is that lock-based
programs do not compose: correct fragments may fail when
combined. For example, consider a hash table with thread-safe insert
and delete operations. Now suppose that we want to delete one item A
from table t1, and insert it into table t2; but the intermediate
state (in which neither table contains the item) must not be visible
to other threads. Unless the implementor of the hash table
anticipates this need, there is simply no way to satisfy this
requirement. [...] In short, operations that are individually
correct (insert, delete) cannot be composed into larger correct
operations.
\end{quote}

# —Tim Harris et al., "Composable Memory Transactions", Section 2: Background, pg.2

Clojure provides support for mutable data through the use of
transactional references: =ref='s.  Modifications to the data must be
wrapped in a transaction and may be protected by a validator function.
This validator function provides another point at which system
integrity may be verified.  When the validator is called the nature of
the transaction is unknown so method pre and post conditions are
inappropriate but this hood does provide an ideal point for
maintaining data invariants.

* Design goals for a Design by Contract framework

Clojure provides Eiffel like pre and post condition checking through a
simple assertion mechanism.  But as a functional programming language,
function arguments are often functions themselves.  Simple pre and
post condition assertions can not verify these functional arguments as
the can only be checked when invoked.  

In order to increase the ability to use Design by Contract techniques
in Clojure, we intend to construct a library which provides support
for high order contract checking based on the work of \cite{hof}.  The
library should be written in terms of Clojure itself and should
allow us to easily view the contracts pertinent to a function.  The
ability to adjust the detailed behaviour of the framework to suit
different usages is also desirable.




* A Clojure implementation

** Terminology

In the following section we develop a Clojure implementation of a
Design by Contract framework.  A number of functions go through an
evolution as the implementation is refined.  Non-final function
definitions are named with numeric suffices: =myfunc-1=, =myfunc-2=
etc., the final form being =myfunc=.  References in the text to the
entirety of this evolving family of definitions are made as
=myfunc-*=.

** An initial approach

Our initial implementation is based on that described by Findler and
Felleisen \{hof}. In Listing \ref{lst:wrap} we define a function, =wrap= which
is used to provide validation of a function parameter.  Should the
parameter be first-order, =wrap= will trigger an immediate assertion
check.  High order parameters, i.e.\nbsp a function which will be used
later, are replaced by a new function which wraps the original in a
contract checker.



Should the contract fail, blame will be assigned based on whether the
pre or post condition was responsible.  An error message can be
emitted with the culprit identified appropriately.

#+srcname: preamble
#+begin_src clojure :tangle yes :exports none 
(ns dbc.core
  (:use clojure.test clojure.walk clojure.contrib.condition [clojure.contrib.string :only (substring?)]))
;; Commentary
;; This file is generated from the literate programming sources in
;;  impl.org, use that as the master.

;;
;; All contracts pertain to the arguments to this function so if the
;; argument is a high order function, then the contract states: "takes
;; a function which returns positive numbers" or some such.

;; So how do we describe that contract?

;; "takes a positive number": (pos ?)
;; "takes a function which returns a positive number": ?



(declare make-contract dom rng flat?)

(defn lenient [_]
  true)

(defn strict [_]
  false)



(deftest contract-construction
  (testing "Flat predicate"
    (is (flat? :foo))
    (is (not (flat? (make-contract :foo :bar)))))
  (testing "Contract construction"
    (is (= 4 (count (make-contract :foo :bar))))
    (is ((dom (make-contract lenient lenient)) 42))))





;; (defn pred [contract value]
;;   "CONTRACT must be a function which accepts a single value to check."
;;   (contract value))

(defn pred [contract value]
  "CONTRACT must be a function which accepts a single value to check."
  ( (if (symbol? contract)
      (resolve contract)
      contract) value))

(declare fo-wrap ho-wrap)

                                        ; TODO look at using clojure-contrib.condition/raise here
(defn    contract-error [position]
  (throw (Exception. (str "Contract failed: " position))))


#+end_src

#     Mutual recursion, as in ho-warp and wrap, probably ought to
#     use trampolining:
#     http://groups.google.com/group/clojure/msg/3addf875319c5c10

TODO need two versions of =pred=, second of which introduces =resolve=

#+latex: \begin{listing}[H]
#+LATEX: \caption{Clojure implementation of \texttt{wrap}}\label{lst:wrap}
#+srcname: wrap1

#+begin_src clojure :tangle yes :exports code
(defn wrap [contract value p n]
  (if (flat? contract)
    (fo-wrap contract value p n)
    (ho-wrap contract value p n)))

(defn fo-wrap  [contract value p n]
  (if (pred contract value)
    value
    (contract-error p)))

(defn ho-wrap [ct x p n]
  (let [d (dom ct)
        r (rng ct)]
    (fn [y] (wrap r
                  (x (wrap d y n p))
                  p
                  n))))
#+end_src
#+latex: \end{listing}



Findler et al. refer to =wrap= as a contract monitor, we prefer
Contract Enforcement Point (CEP) as "monitor" seems a somewhat passive
description of something which has the ability to terminate a
program.  This also allows the use of Contract Definition Point (CDP)
for the location in the program text where the contract is defined.
This emphasises the separation between definition and enforcement and
provides a useful comparison with the terminology used in policy based
management \cite{RFC3198}.


The underlying contract implementation is hidden behind utility
functions.  We need to select a data structure to represent the
contracts.  As is idiomatic in Clojure development, the first data
structure of choice is =map=.  Here we define two keys, =:dom= and
=:rng= to hold the domain and range (pre and post conditions).  We
provide two implementations of =make-contract=: =make-contract/2= is
a simple shorthand version which calls =make-contract/4= with default
values of the message to be used in the case of pre or post condition
failure.


#+begin_src clojure :tangle yes :exports code
(defn make-contract 
  ([pre post]
     (make-contract pre post "Pre condition failed" "Post condition failed"))
  ([pre post pre-message post-message]
     {:dom pre :rng post :pre-message pre-message :post-message post-message}))

(defn dom [contract]
  (:dom contract))

(defn rng [contract]
  (:rng contract))

(defn flat? [x]
  (not (map? x)))
#+end_src

To examine how this works we look first at an Eiffel style first order
contract. We define a faulty single parameter function which requires
its argument to be positive and guarantees its return value is also
positive.


#+latex: \begin{listing}[H]
#+latex: \caption{First order require/ensure implementation} \label{lst:fo}
#+srcname: lst:fo
#+begin_src clojure :tangle yes :exports code
(defn gt0? [x]
  (and
   (number? x)
   (pos? x)))

(def faulty-sqrt
  (wrap (make-contract gt0? gt0?)
        (fn [not-used] -1)
        "Post condition violated" "Pre condition violated"))

(deftest faulty-sqrt-test
  (is (thrown-with-msg? java.lang.Exception #"Post condition" (faulty-sqrt 1)))
  (is (thrown-with-msg? java.lang.Exception #"Pre condition" (faulty-sqrt 0))))
#+end_src
#+latex: \end{listing}




In Listing \ref{lst:fo} we introduced the predicate =gt0?= to verify
that the argument is both numeric and greater than zero. A naive use
of the predicate =pos?= will cause a =java.lang.ClassCastException= to
be thrown if something other than a number is passed in.  As this
exception will bypass our blame assignment we need to protect against
it.  This form of category error, failing to predicate all possible
argument types that the function may be called with, is easily made
when the programmer is focusing purely on defining the function and
contract at hand.  In normal Clojure development the error would then
be caught either at the REPL or during more formal testing, but that
negates the value of our Design by Contract harness.  We will
therefore wish to provide a library of basic predicates such as =gt0?=
which accept a wider category of inputs.

=faulty-sqrt= demonstrates blame assignment, allowing the user of a
function to determine whether it is the called or calling function at
fault. Calling =(faulty-sqrt 1)= will throw an exception declaring
that the post condition was violated, a fault in the called function,
whilst =(faulty-sqrt 0)= will declare that the pre condition has been
violated, with the caller at fault.


To demonstrate the application of =wrap= we use a simple high order
example  based on section 2.2 of \cite{hof}. Consider a function
=save= which saves a function and =use= which later calls the saved
function, activating its contract.  We wish to constrain =save= to
only accept functions which take and return  numbers greater than 0.  


#+latex: \begin{listing}[H]
#+latex: \caption{Application of \texttt{wrap}} \label{lst:ff-use}
#+srcname: ff-use
#+begin_src clojure :tangle yes :exports code
(def ff-saved (ref (fn [not-used] 50)))



  ;;; (bigger-than-0 -> bigger-than-0) -> any
(defn ff-save [f] (dosync (ref-set
                           ff-saved
                           (wrap (make-contract gt0? gt0?) f "p" "n")) ))


  ;;; bigger-than-0 -> bigger-than-0
(defn ff-use [n] (ff-saved (wrap gt0? n "p" "n")))


(deftest ff-example ;\ref{line:test}
  (ff-save (fn [not-used] 50))
  (is (= 50 (ff-use 42)))
  (is (thrown? java.lang.Exception (ff-use -1)))
  (ff-save (fn [not-used] -1))
  (is (thrown? java.lang.Exception (ff-use 42))))
#+end_src
#+latex: \end{listing}



Listing \ref{lst:ff-use} also adopts the comment contract
specification notation from \cite{htdp} to specify the expected types
of arguments and return values.  But it is the goal of executable
contracts to replace that information in an enforceable way without
the redundancy of unconnected commentary.  We will visit this problem
in section \ref{selfdocumenting}.

The =deftest= of Listing \ref{lst:ff-use} validates our contract
implementation, demonstrating that exceptions are thrown  should
either the argument or return value of the stored function be less
than zero. Similar unit tests are provided for the rest of our
framework implementation but are omitted from this document.





** Code generation
\label{codegen}
Although logically correct, manually wrapping each occurrence of a
parameter in calls to =wrap= is tedious and error prone; the sort of
thing computers were intended to relieve us from.  Clojure, like other
Lisps, has a sophisticated macro system which can be used to
automatically generate this code.  We will be using this macro system
to allow us attach contracts to functions, automatically wrapping the
arguments.  We first look at a monolithic approach to the problem
where we define a new macro, =defcontract= which requires access to
the body of the function we are applying contracts to.  We then
examine a second, superior, version where existing functions may have
contracts attached to them, without requiring access to the function body.


*** Monolithic approach

Inspired by an intent to emulate the function definition macro =defn=,
with support for contracts on higher order functions, we construct a
macro =defcontract=.  For simplicity we only consider functions taking
a single argument.

#+latex: \begin{listing}[H]
#+latex: \caption{An initial contract macro} \label{defcontract1}
#+srcname: label
#+begin_src clojure :tangle yes :exports code
(defmacro defcontract-1 [fn-name a c body]
  (let [wrapped-arg {a `(wrap ~c ~a "p" "n")} ] 
    `(defn ~fn-name [~a]
       ~(clojure.walk/postwalk-replace wrapped-arg body))))


(defcontract-1 ff-save-2 f (make-contract gt0? gt0?)
  (dosync (ref-set ff-saved f)))

#+end_src
#+latex: \end{listing}

Examining what's happening in Listing \ref{defcontract1}: the =let=
line creates =wrapped-arg=, a map holding the original function
argument and its intended replacement. This replacement argument calls
=wrap= with both the original argument and its contract. The following
line, starting with =`= forms the new function definition; forms
prefixed with \tilde are replaced with the result of their evaluation,
all other forms are rendered verbatim.  The function
=postwalk-replace= will replace each occurrence of the original
argument with its wrapped equivalent.

The overall result of this macro is to create a function definition
with every use of an argument wrapped in a call to the =wrap= function
of Figure \ref{lst:wrap}. 


As well as checking the argument to the function =fn-name= defined
using =defcontract-1=, we need to verify the return value from the
function.  There are two possible approaches to this: we could use
Clojure's pre-existing post condition check, =:post= discussed previously, or
we could use the =wrap= function developed above.  The use of =:post=
checks would limit us to simple flat asserts about the return value,
whereas we would like to still have the ability to check high order
function returns.  Accordingly we will use =wrap= to verify return
values from functions defined using =defcontract-2=


Using this macro we can simplify the definitions of =ff-use= and
=ff-save= from Listing \ref{lst:ff-use} to:


#+latex: \begin{listing}[H]
#+latex: \caption{ff-save implemented with the contract macro.} 
#+latex: \label{lst:ff-use2}
#+srcname: label
#+begin_src clojure :tangle yes :exports code
  (defcontract-1 ff-use-2 n gt0?
    (ff-saved n))
#+end_src
#+latex: \end{listing}
#+begin_src clojure :tangle yes :exports none

(deftest ff-example-2 ;\ref{line:test}
  (ff-save-2 (fn [not-used] 50))
  (is (= 50 (ff-use-2 42)))
  (is (thrown? java.lang.Exception (ff-use-2 -1)))
  (ff-save-2 (fn [not-used] -1))
  (is (thrown? java.lang.Exception (ff-use-2 42))))

(defmacro defcontract-2 [fn-name a c post body]
  (let [wrapped-arg {a `(wrap ~c ~a  "post condition of arg" " pre condition of arg")} ] 
    `(defn ~fn-name [~a]
       (wrap ~post 
             ~(clojure.walk/postwalk-replace wrapped-arg body)
             "Post condition of function return" "Pre Condition of function return"))))




(defcontract-2 ff-save-x f 
  (make-contract gt0? gt0?)
  lenient
  (dosync (ref-set ff-saved f)))

(defcontract-2 ff-use-x n
  gt0?
  lenient
  (ff-saved n))



(deftest ff-example-x ;\ref{line:test}
  (ff-save-x (fn [not-used] 50))
  (is (= 50 (ff-use-2 42)))
  (is (thrown? java.lang.Exception (ff-use-x -1)))
  (ff-save-x (fn [not-used] -1))
  (is (thrown? java.lang.Exception (ff-use-x 42))))





#+end_src

The macro defined in Figure \ref{defcontract1} successfully automates
the process of wrapping function parameters in contract checking
code. Unfortunately the resulting code is monolithic; conflating
function implementation and contract.  This dramatically reduces
modularity - one of the key advantages of functional programming
according to \cite{hughes}. When used for functions like the =sqrt=
example this is not too disastrous: the contract is a consequence of
the underlying mathematics of the implementation.  But if we need
similar contracts for other functions reuse will be limited.  In some
cases contracts will be used to impose business rules on a function,
rather than implementation artefacts.  In those cases we may wish to
reuse the function implementation with a different contract in an
alternative environment.

Ideally a contract should just be an aspect of the function, along
with its implementation.  Aspect Oriented Programming has been used
\cite{aopdbc} to implement Design by Contract in AspectJ.  We're
seeking to develop a similar approach where the contract and
underlying function implementation can be specified separately and
combined at will. An example of this, for first order contracts, is
given in \cite[p.\ 173 - 175]{joy}.  


We therefore consider an alternative approach where we
produce a function which acts a facade to the original: calling it
with its argument list replaced by arguments which have been protected
by calls to the =wrap= function described above:

#+BEGIN_SRC clojure :tangle yes :exports code
(defn wrapit [myfn arg contract]
  (myfn (wrap contract arg "post" "pre")))
#+END_SRC

Whilst we could manually create these facades for all of our
contracted functions, that would involve a lot of repetitive boiler
plate coding.  This is where Lisp macros are useful.  The =wrapit=
function above provides an example of the output we wish, so we use
that to design our macro.

We forward declare a pair of functions: =wrap-arg-contract= will
apply wrap to an argument and contract extracted from a list;
Clojure's de facto pair representation; =zip= will produce a list of
such pairs from two separate lists.  Implementation of these two will
follow once we have examined the main =attach-contracts= macro.  Once
the code is fully presented we will look at the macro expansion from
a simple use and compare the generated code to that of =wrapit= above.

#+latex: \begin{listing}[H]
#+latex: \caption{A modular approach to applying contracts}\label{attach-contracts} 
#+BEGIN_SRC clojure :tangle yes :exports code
(declare wrap-arg-contract zip)

(defmacro attach-contracts [newname func contracts]
  "Create a new function definition `newname' which calls
  `func' with the args stored in arg/contracts wrapped in
   the corresponding contract."
  (let [args (vec (map gensym contracts))]
    `(defn ~newname ~args
       (let [wrapped-args# 
             (map wrap-arg-contract (zip ~args ~contracts))]
         (apply ~func wrapped-args# )))))


#+END_SRC
#+latex: \end{listing}

As before, this emits a function definition.  The difference to that
in the =defcontract= macro is that in the last line the call to
=apply= invokes a function call with wrapped arguments.  The =let=
line of the implementation constructs a vector to be used as the
argument list in the the newly defined function.  There will be as
many arguments as there were contracts passed in to the call to
=attach-contracts=.  In order to build this vector we map =gensym=
over the =contracts= vector.  Invoking =gensym= will return a new
symbol with a unique name so =args= will be a vector of such symbols;
ideal for use as an argument list.  In the =defn= line, =~newname= is
replaced by the =newname= parameter passed in to the macro and
=~args= by our newly created vector of symbols.


#+latex: \begin{listing}[H]
#+latex: \caption{Supporting functions for attach-contracts}
#+BEGIN_SRC clojure :tangle yes :exports code
(defn wrap-arg-contract [arg-contract]
  "Extracts the contract from the pair arg-contract and returns
   arg wrapped in that contract"
  (let [arg (first arg-contract)
        contract (second arg-contract)]
    (wrap contract arg
          (:post-message contract)
          (:pre-message contract))))


(deftest wrap-test 
  (is (= 4
         (wrap-arg-contract (list 4 gt0?))))
  (is (thrown-with-msg? java.lang.Exception #"Contract failed"
        (wrap-arg-contract (list 0 gt0?)))))


(defn zip [a b]
  "Returns a lazy sequence consisting of pairs made of the first
  elements of a and b, second etc."
  (map list a b))


(def faulty-sqrt-2
  (wrap-arg-contract (list (fn [not-used] -1)
                           (make-contract gt0? gt0?))))

(deftest faulty-sqrt-2-test
  (is (thrown-with-msg? java.lang.Exception #"Post condition"
        (faulty-sqrt-2 1)))
  (is (thrown-with-msg? java.lang.Exception #"Pre condition"
        (faulty-sqrt-2 0))))


#+END_SRC
#+latex: \end{listing}


Considering the trivial case of a function which adds its two
arguments, but requires them both to be positive.  We define a simple
=add-args= function to perform the arithmetic and then call
=attach-contracts= to give a new function, add-args-c,  which imposes
=gt0?= on the two arguments.


#+BEGIN_SRC clojure :tangle yes :exports code
(defn add-args [a b]
  (+ a b))

(attach-contracts add-args-c
                  add-args
                  [gt0? gt0?])

(deftest add-args-test
  (is (= 8
         (add-args-c 4 4)))
  (is (thrown-with-msg? java.lang.Exception #"Contract failed"
        (add-args-c 0 4))))

#+END_SRC

To understand what the =attach-contracts= macro is doing we can use
clojure's pretty print and macroexpand functions to see the code
which is generated at compile time:

#+latex: \begin{listing}[H]
#+latex: \caption{Macro expansion of attach-contracts}\label{macroexpand} 
#+BEGIN_SRC clojure :tangle no :exports code 
(clojure.pprint/pprint (macroexpand-1
                        '(attach-contracts
                          add-args-c
                          add-args
                          [gt0? gt0?])))

=>

(clojure.core/defn
  add-args-c
  [gt0?2398 gt0?2399]
  (clojure.core/let
   [wrapped-args__2280__auto__
    (clojure.core/map
     dbc.core/wrap-arg-contract
     (dbc.core/zip [gt0?2398 gt0?2399] [gt0? gt0?]))]
   (clojure.core/apply add-args wrapped-args__2280__auto__)))

#+END_SRC
#+latex: \end{listing}

We see from Listing \ref{macroexpand} that the macro expansion of
=attach-contracts= emits code for the function definition of
=add-args-c=.  The strangely named arguments to that function,
=gt0?2398= and =gt0?2399= are an artefact of the call to =gensym= in
the preamble to attach-contracts.  We see in the last line of the
expanded macro a call to =apply= which causes the original =add-args=
function to be called with arguments formed by wrapping the arguments
passed to =add-args-c=.





** Separation of concerns
*** TODO this needs to be tangled
#+latex: \begin{listing}[H]
#+latex: \caption{Separating contract from implementation} \label{lst:joy}
#+srcname: aop
#+begin_src clojure :tangle no :exports code
(declare collect-bodies)

(defmacro contract [name & forms]
  (list* 'fn name (collect-bodies forms)))

(declare build-contract)

(defn collect-bodies [forms]
  (for [form (partition 3 forms)])
  (build-contract form))

(defn build-contract [c]
  (let [args (first c)]
    (list
     (into '[f] args)
     (apply merge
            (for [con (rest c)]
              (cond (= (first con) :require)
                    (assoc {} :pre (vec (rest con)))
                    (= (first con) :ensure)
                    (assoc {} :post (vec (rest con)))
                    :else (throw (Exception. (str "Unknown tag " (first con)))))))
     (list* 'f args))))
#+end_src
#+latex: \end{listing}

Listing \ref{lst:joy} defines =contract= which is used to populate the
pre and post conditions of a =fn=.  Wrapping this in a call to =def=
reproduces the functionality of =defn= as described in section
\ref{defn} above.  This allows us to define contracts and then
associate them with a function.  For example a doubler-contract which
requires a function to double the value of its argument can be
associated with a function =times2= which does just that:

** TODO tangle this too
#+latex: \begin{listing}[H]
#+latex: \caption{Composition of contract function and constrained function} \label{lst:joy2}
#+srcname: aop
#+begin_src clojure :tangle no :exports code
(def doubler-contract
  (contract doubler [x]
            (:require (pos? x))
            (:ensure (= (* 2 x) %))))

(def times2 (partial doubler-contract #(* 2 %)))
#+end_src
#+latex: \end{listing}




Unfortunately here we come across a problem.  For a first order
contract, the contract term can simply verify the pre conditions of the
function and pass the now checked value through to the original
function.  With a high order contract, the contract cannot be fully
verified before the function is executed in place.  As in Listing
\ref{lst:joy} we do not have access to the original function body, we
cannot replace the parameter usage sites with appropriately wrapped
versions. Unless we resort to recompiling the target function on the
fly we are constrained to an intrusive implementation of Design by
Contract.

** Blame assignment
In order to assist the debugging process we wish to able locate the
code involved in contract failures.  Our intent is to provide that
information in the same format as produced by tools such as gcc so
that other development tools can easily utilise the data, perhaps
taking the user to the corresponding file. File and line information
is available in Clojure, but accessing it will require a short tour of
some of the language's internals.

A basic building block of Clojure is the =var=.  From
clojure.org/vars: "Vars provide a mechanism to refer to a mutable
storage location that can be dynamically rebound (to a new storage
location) on a per-thread basis. Every Var can (but needn't) have a
root binding, which is a binding that is shared by all threads that do
not have a per-thread binding. Thus, the value of a Var is the value
of its per-thread binding, or, if it is not bound in the thread
requesting the value, the value of the root binding, if any."

Vars are created using the =def= special form: =(def name value)=
which also creates a metadata map including entries for =:file= and
=:line=.  Of interest to us is the fact that a function definition
=(defn name [params*] exprs*)= is equivalent to defining a var =name=
as =(def name (fn [params* ] exprs*))=.  We therefore have access to
the file and line in which a function is defined. This is the
information we wish to present to our users.  To provide an accessor
to this information we use the following macro:

#+latex: \begin{listing}[H]
#+latex: \label{lst:source-loc}
#+srcname: label
#+begin_src clojure :tangle yes :exports code


(defmacro loc [sym] `(format "%s:%s"
                             (:file (meta (var ~sym)))
                             (:line (meta (var ~sym)))))
#+end_src
#+latex: \end{listing}


As before, the backquoted form is inserted verbatim, except that
\tilde escaped forms are evaluated before insertion.  The =var=
special form returns the Var object (not the value) that =sym= refers
to, and =meta= in turn accesses the metadata of the Var object.  We
are forced to use a macro rather than function call here because =var=
requires a symbol which refers to a Var whilst a function argument is
a symbol whose value will refer to a Var object.  

Although we now have access to the location of the contract which
failed, we have little information available about how we got there.
In the event of a failed contract, we wish to be able to report the
sequence of events which lead up to the failure.  This is typically
achieved through a stack trace: a description of the function call
stack. Clojure's ability to call Java methods directly allows us to
access the function call stack as shown in Listing \ref{stacktrace}


#+latex: \begin{listing}[H]
#+latex: \caption{Stack trace} \label{stacktrace}
#+srcname: label
#+begin_src clojure :tangle yes :exports code

(defn ignored? [classname]
  (let [ignored #{"callers" "dbg" "clojure.lang" "swank" "eval"}]
    (some #(substring? % classname) ignored)))

(defn callers []
  (let [fns (map #(str (.getClassName %))
                 (-> (Throwable.) .fillInStackTrace .getStackTrace))]
    (vec (doall (remove ignored? fns)))))

#+end_src
#+latex: \end{listing}

A brief explanation of Clojure's syntax here: =(.method object args)=
is syntactical sugar for a Java call =object.method(args)= so the
=callers= function above creates a new =Throwable= object and
populates its stack trace: a typical Java solution to the problem.
The final line of =callers= prunes the stack trace, removing function
calls which are an artefact of the development environment.

For first order contracts this provides a good solution: the contract
will be evaluated at the same time that it is applied.  In the event
of failure a stack trace can be generated, describing the sequence of
events, on this thread at least, which resulted in the contract
violation.  Things are not so simple for higher order contracts.  The
contract is not evaluated at the time it is applied but rather
deferred until the contracted function is executed.  The stack trace
at contract evaluation time gives little information about the state
of the program at the point the contract was applied, so we need to
generate the stack trace at contract application time.

Unfortunately here we face a potential performance impact.  Because of
the delayed contract checking of high order functions, we don't know
at the time we apply a contract whether or not that contract will be
fulfilled and hence whether or not the stack trace will be needed.
Accordingly we must generate a stack trace for every contract
application: a potentially expensive process.  An approach to
mitigating the impact of this is described in \ref{meta}.

** Contract Documentation
\label{selfdocumenting}
To be completed - brief description of contracts as meta data to
function, functions to print that meta data

** Meta Framework

So far we have made a number of assumptions about how the framework
will be used.  Some of these, such as our contract violation reporting
mechanism =contract-error=, will be inappropriate for many users.
Taking inspiration from the CLOS Meta Object Protocol \cite{kiczales},
we look for points of variation and introduce the ability to adapt our
framework to a user's needs.

The first and most obvious variation point is the action to
undertake in the event of a contract violation.  Appropriate behaviour
depends on the application, state of development (developer build or
customer release) and the error philosophy of the development team.
More interestingly, different parts of the program may require
different error handling.  McConnell \cite[p.\ 103]{codecomplete} takes the
example of a spreadsheet program where failures in the screen refresh
code should be handled differently to failures in the underlying
calculation engine.  A similar claim that runtime contract failure
should be customisable is made for Microsoft's recent contract
framework \cite{ECL}.

Clojure's dynamic variables provide the ability to rebind a variable.
This is distinct from simply shadowing the original; shadowing will
mask a variable within the lexical scope of the shadow whilst
rebinding provides the dynamic scope which we need to allow us to pass
closures around as first class objects.  When a contract was applied to
a parameter, a harsh contract failure penalty may have been in place,
but when we come to use the parameter it may be that the penalty for
failure has been relaxed in which case a closure over a lexically
declared error behaviour would give unwanted behaviour. This is
similar to the common library problem \cite{8ways} where the application
developer does not wish to be constrained by the error reporting
mechanism of the library developer.



#+latex: \begin{listing}
#+latex: \caption{Customising failure behaviour} \label{lst:contract-failure}
#+begin_src clojure :tangle yes :exports code
(defn simple-contract-error [position]
  (throw (Exception. (str "Contract failed: " position))))

(def ^{:doc "Function to call on failure of a contract"}
  ,*contract-failure-function* #'simple-contract-error)

(defn contract-error [position]
  (*contract-failure-function* position))


#+end_src
#+latex: \end{listing}

Listing \ref{lst:contract-failure} shows such a rebinding in use.
=*contract-failure-function*= is called on failure.  The programmer
can bind this symbol to a function providing the required behaviour.
The =*= decoration on the function name, often called ear muffs, is
purely a conventional notation to denote a dynamic variable.

We \label{meta} could use different implementations of =contract-error= to generate
the expensive stack traces of Listing \ref{stacktrace} or a simpler,
but less informative implementation.
  

\cite{citeulike:661450} extends the blame assignment of \cite{hof} to
provide additional information about those responsible for a contract
violation.  Given that we now know of two plausible implementations of
blame assignment, this makes another good variation point to allow for
future extension.


#+latex: \begin{listing}
#+begin_src clojure :tangle yes :exports code
(defn combine-loc-ff [l1 l2]
  (take 2 (flatten (vector l1 l2))))
#+end_src
#+latex: \end{listing}

This implementation makes it clear that we discard information: only
the first two elements of the combined location are preserved.  The
version of \cite{citeulike:661450} preserves all locations
accumulated to date which we can implement simply by discarding the
truncating =take=.

#+latex: \begin{listing}
#+begin_src clojure :tangle yes :exports code
(defn combine-loc-hjl [l1 l2]
  (flatten (vector l1 l2)))
#+end_src
#+latex: \end{listing}

We now provide a default implementation and an implementation of their
of their $\rightslice$ operation which combines locations, interchanging
positive and negative locations when necessary.

#+latex: \begin{listing}
#+begin_src clojure :tangle yes :exports code
(def combine-loc #'combine-loc-hjl)

#+end_src
#+latex: \end{listing}

** Lazy evaluation

As pointed out in \cite{imprecise-exceptions}, the addition of
exception handling to a lazy language can cause  increased strictness
by testing a function argument for errors when it's passed rather than
when it is used.  It is important that our wrap mechanism should not
cause unwarranted evaluation of lazy sequences. 




** Post conditions and exceptions
The post condition handling we have considered so far is limited to
the case of a normal return from the function.  As we have seen,
Clojure integrates tightly with Java and can throw Java exceptions or
call Java code which in turn throws an exception.  We would like to be
able to impose post condition contracts on this alternative exit.


** Clojure and object oriented programming 

Clojure supports two separate approaches to object oriented
programming.  Since the 1.0 release there has been support for CLOS
style generic methods; a method is declared as generic and then
implementations are provided for different argument types.  This
naturally provides support for multimethods: implementations are
chosen based on the type of all, not just one, of their arguments.


More recent versions of Clojure also support protocols.  These are a
named set of named methods, effectively an interface definition.  A
type then defines which protocols it implements.  It is this latter
approach which we will consider.

As there is no implementation inheritance, we can limit our contracts
to just applying to the definition of the protocol.  A case could be
made for supporting Liskov Substituion, allowing the protocol
implementation to strengthen the post conditions or weaken the
pre conditions.  From a pragmatic view point, the author feels that
this would just lead to increased difficulties in usage.  Though a
programmer should adhere to the defined protocol contract, if in
practice a weaker contract were implemented it is possible that the
observed behaviour would be assumed to be the documented interface and
so changing implementations could lead to unexpected contract
violations .

* A worked example

My day job is to develop software for video conferencing
infrastructure; effectively a telephone exchange for video
conferencing.  In order to test this we use a number of video
endpoints (analogous to a telephone) to place calls in to the
system.  Interoperability between our equipment and the various
endpoint manufacturers is an important requirement so we test using a
range of endpoints.

The endpoints all nominally speak the standardised protocols, SIP and
H.323, over the LAN to the infrastructure equipment.  They also
provide APIs to allow automation of call setup and tear down as well
as status reporting. These APIs vary widely, not only between
manufacturers but also between product lines from a single
manufacturer.

We will provide a series of device specific functions to request an
endpoint to make a call setup attempt. These will use simple first
order contracts to check their pre and post conditions: have they
been given a valid endpoint address and a valid SIP URI, are they
returning an agreed value.

Another suite of device specific functions will query the endpoint as
to whether or not it is actually in a call: not all call setups are
answered.



#+latex: \begin{listing}[H]
#+latex: \caption{Example contract use} 
#+begin_src clojure :tangle yes :exports code

(defn sip-uri? [s]
  "True if s is a plausible SIP URI.  This is a very weak implementation, 
       merely checking for the presence of @, a real version should consider using 
       javax.sip.address"
  (and
   (string? s)
   (substring? "@" s)))

(import sun.net.util.IPAddressUtil)
(defn ip-address? [s]
  "True if s is a plausible string representation of an IPv4 address"
  (and
   (string? s)
   (IPAddressUtil/isIPv4LiteralAddress s))) 

(defn call-setup-hdx [endpoint-ip alias]
  "Place a call setup attempt from the HDX at `endpoint-ip' to the SIP URI `alias'"
  ;; code omitted
  )


(defn call-established-hdx? [endpoint-ip timeout]
  "Waits up to `timeout' to see if the HDX endpoint at `endpoint-ip' is in a call"
  ;; code omitted
  )

#+end_src
#+latex: \end{listing}

For a simple call test we wish to place a call to an alias which,
barring product bugs, should be answered within 5 seconds.  We
therefore combine the call setup and status query in a blocking
function which will return on successful call setup, call setup
failure or failure to establish a call within the given time limit.
This takes the two device specific functions as arguments.

#+BEGIN_SRC clojure
;; setup-fn takes an valid SIP URI and returns {:ok,:setup-failed}
;; established-fn? returns {true, nil}
;; alias is a SIP URI
(defn blocking-setup [setup-fn, established-fn?, alias]
  (setup-fn alias)
  (established-fn? 5))

#+END_SRC    

We wish to allow teh independent development of support for new
endpoint types, but also need to ensure that the interface software
developed for those new endpoints conforms to the needs of our test
harness.  Whilst specifying the requirements in the test harness
documentation ought to suffice, experience has shown that
documentaion is often not consulted and even if checked, constraints
not necessarily complied with.  We will therefore establish contracts
on our test harness software which place obligations on the functions
passed to it.
* Discussion

** On learning Clojure

One of the stated goals of this project was to learn more about
Clojure as a language.  The two different approaches to applying
contracts to functions; the monolithic and modular approaches of
\ref{codegen} arose through my initial unfamiliarity with the
language.  My first attempts at writing a macro to wrap function
arguments failed with a number of errors related to symbol resolution
and inadvertent variable capture or anaphora.  Rather than stepping
back and finding a simpler approach I began trying to resolve each
immediate error and soon became enmeshed in a hopelessly complicated
code.  Deciding that a modular solution could not be produced in
Clojure, I came up with the monolithic solution presented in Listing
\ref{}.

As the dissertation progressed my familiarity with the language, and
in particular macros, increased.  Prompted by a question from my
tutor, Dr Hinze, I revisited the modular solution and this time was
able to achieve a satisfactory solution --- the =attach-contracts=
macro of Listing \ref{ }.  So why did I initially go down a blind
alley; more importantly is that reason relevant to the rest of my
programming? 


** Meta programming

TODO discuss 

- problems with initial monolithic wrap implementation

- symbols, anaphora intoduced by =~'foo= 

** The current state of Design by Contract 

As we have seen, Clojure has basic support for pre and post condition
checking, and there are some enthusiastic blogs \cite{onclojure-blog},
\cite{objectcommando-blog} commenting on the possibilities. But
despite this, current practice does not extend to significant use of
these techniques. Examination of typical libraries reveals little
usage: =clojure-contrib= currently (Version 1.2) has one =:pre= check
in 27,000 lines of code. In contrast there are 41 asserts.

A similar picture emerges for the use of validator functions, there
are no calls to =set-validator!= in =clojure-contrib=.  Refs are in
use though: the transaction functions used to alter them are called
several times:

| mutating function | frequency |
| =ref-set=         |        22 |
| =alter=           |        11 |
| =commute=         |         7 |

To endeavour to promote a more complicated contract checking mechanism
on a community which has not adopted first order contract checking is
unlikely to be worthwhile.  So why has the Clojure, and wider,
community not adopted Design by Contract?  Whilst I am unaware of any
formal studies into this, a widely heard response \cite{why-dont},
\cite{irc-clojure} combine the difficulty of identifying the relevant
contracts whilst creating a function and the difficulty in then reusing
or refactoring this constrained code. 

An extreme example of the difficulty of reuse is the Ariane 5 rocket
failure.  The software was based on that used in the Ariane 4
programme.  Unfortunately the rocket hardware had improved to such an
extent that a previously impossible flight trajectory could now be
achieved.  This resulted in an integer overflow, which was not
protected as after inspection with the original hardware in mind, it
was determined that the situation could never arise.  In order to
preserve CPU cycles, checks were limited to those cases where it was
deemed possible for the errors to occur.

The enquiry into the failure recommended\cite{ariane}
 
"R12 Give the justification documents the same attention as
code. Improve the technique for keeping code and its justifications
consistent."

The idea being that, on reuse of the Ariane 4 code, the assumptions
and justifications could be readily seen.  But the problem of keeping
documentation and code in synchronisation is a long known one, indeed
one of the drivers behind Eiffel's short form.  So could we not
document our assumptions in the code as contracts and then,
independently, determine whether or not to enforce those contracts?



* Conclusions

To Be Completed

\pagebreak
\bibliographystyle{alpha}
\bibliography{dbc}

* Notes :noexport:


make-contract is actually making a HIGH ORDER contract.  First order
contracts are flat assertions.

what do we do about functions that take more than one parameter?
Need to work out some use of =partial= to give us what we need.
Current post condition check is an ugly special case.

Same problem applies to function args that are fns of more than one
arg.  This must be symmetric surely.





** Existing work

There's a contracts library at http://www.fogus.me/fun/trammel/docs.html

**  Runtime vs Compile time contract assignment



Is there any benefit in using hooks to give the ability to set contracts at run time?












MSFT .NET http://research.microsoft.com/en-us/projects/contracts/






Code Contracts User Manual
Microsoft Corporation January 8, 2012




Inability to make contracts plugin to function.  Flies againdt
modularity argument of "Why Functional Programming matters", Hughes 1990




#clojure: <2012-08-03 Fri> 
<ohpauleez> 1.)
People move code around like clay - they don't quite think as
	    far ahead or careful as someone like Rich might
<ohpauleez> it's hard to come up with the constraints of a system that you
	    yourself aren't even sure about  [16:19]
<ohpauleez> 2.) Creating contraints on domain input and output takes practice,
	    just like writing good tests
<ohpauleez> BUT
<ohpauleez> you end up capturing these domains in your tests anyway, you might
	    as well enforce them and program defensively
<ohpauleez> Programming to an interface instead of an implementation helps to
	    avoid pointless dependencies between calling pieces of code

