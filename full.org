#+title:     Design by Contract in Clojure
#+AUTHOR:    Giles Chamberlin
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+LaTeX_CLASS_OPTIONS: [a4paper, 12pt] 
#+LATEX_HEADER: \usepackage{parskip} \usepackage{fourier} \usepackage{minted} \usepackage{cite}
#+LATEX_HEADER: \usepackage{hyperref} \usepackage{stmaryrd} \usepackage{tikz}

# stmaryrd used for \rightslice character used in Hinze paper.


# upquote package is used to get proper back quote behaviour in code
# listings.  Means we can't change from Computer Modern for our tt font

#+LaTeX_HEADER: \usepackage{upquote} \usemintedstyle{bw} 

\renewcommand\listoflistingscaption{Program listings}


# If we set the twoside option to article then the following will
# cause each section to appear on an odd numbered page.
# Ignore this though as requirements are to print single sided. 
# \let\stdsection\section  
# \def\section{\cleardoublepage\stdsection}  

# Start each section on a new page
\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}


\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black,
    pdfauthor=Giles Chamberlin,
    pdfsubject=Submission for M.Sc. in Software Engineering
    pdftitle=Design by Contract in Conjure
}




#+begin_src sh :exports none
  BIBINPUTS=/Users/grc/dissertation/:$BIBINPUTS
  export BIBINPUTS
#+end_src


\begin{abstract}
What hath I wrought?
\end{abstract}

The author confirms that this dissertation does not contain material
previously submitted for another degree or academic award; and that the
work presented here is the author's own, except where otherwise
stated.

\pagebreak
[TABLE-OF-CONTENTS]

\listoflistings
\pagebreak
* Introduction

Writing a correctly functioning computer program is hard.  And it's
not going to get easier.  In a programmers' arms race a number of
tools and techniques have evolved which help maintain a degree of
control over the burgeoning complexity of the systems we are creating.
In response, the systems we are trying to build have become still more
complicated: all the easy problems have been solved.

One area of increasing complexity is the growth of parallelism in many
modern systems.  This is encouraged by the fact that CPU's are no
longer in a race for the highest clock frequency but the highest core
count.  Intel's next generation of chips provide up to 20 concurrent
threads of execution \cite{intel}.  For a single program to take
advantage of this power it must be able to operate in parallel.  But
writing correct parallel programs is hard.

Functional programming provides one approach to reducing the
difficulty of parallel programming.  As a pure functional program has no side
effects evaluation order is unimportant: functions may be run on any
processor core with impunity.  Although many real world programs
require some side effects to be useful, these can be managed at well
defined points in the program helping to reduce race conditions.  



Another tool to manage program complexity is the assertion: a
statement in the program about the assumed state at that point.
Should the assertion be incorrect, the program is typically
terminated.  Assertions were taken further by Meyer's ideas of Design
by Contract \cite{oosc}, where state is explicitly checked both
before and after a method call.

Most work on Design by Contract has been based around Object Oriented
Programming.  Design by Contract in a functional world brings new
challenges as it is now necessary to deal with functions as first
class objects and reason about their state in addition to assertions
about simple data types.

In this dissertation we take some of the work on Design by Contract in
a functional world and use that to develop a Design by Contract
framework for Clojure.  Clojure is a relatively recent addition to the
set of functional languages.  A member of the Lisp family of
languages, it is based on the Java Virtual Machine and so can take
advantage of the plethora of Java libraries.

In this dissertation we first review the background to Design by
Contract, its inception, current implementations and extension in to
the world of functional programming.  Having outlined design goals for
our framework we will look in some detail at two possible framework
implementations and compare their benefits.  We then study a worked
example to see how our preferred framework could be used in practice.
A section on discussion provides us an opportunity to reflect on the
successes and otherwise of our implementation.  Finally our
conclusions summarise what we have learnt during this process and
point at possible future areas for study.

* A background to Design by Contract


There is a long history \cite{historical} behind the use of assertions
to improve program reliability.  Originally introduced to support
formal reasoning about the state of the program, there has been
significant uptake amongst practising software engineers beginning
with Parnas' description of software module specification
\cite{Parnas}.  The current state of the art is such that assertions
are frequently used pragmatically, to verify assumed state, but rarely
to provide formal proof of the correctness of the program \cite{Hoare}.

In this section we consider the use of run time assertion checking
systems in a number of programming languages.  Our intent is to use this
discussion to ascertain the important features of such a system which
may then be used as the basis for the requirements of a system
implemented in Clojure.


** Eiffel

Meyer's book "Object Oriented Software Construction" \cite{oosc}
introduced the term "Design by Contract" to much of the software
engineering community.  In his book, Meyer lays out his views of how
to develop robust software and in the process introduces a new object
oriented language, Eiffel, which embodies those design principles. One
of the key concepts is the use of pre and post conditions to provide a
contract between the caller and provider of a method.  In the event of
contract violation blame is then assigned depending upon which
condition was violated.

As an example of the notation, consider a truncated version of Meyer's STACK2 class
\cite{oosc}[p.\ 349]
#+latex: \begin{listing}[H]
#+LATEX: \caption{Eiffel's assertion checking mechanism}
#+begin_example
class STACK2[G] creation
  make

feature -- initialization
  make (n: INTEGER) is
           -- allocate a sstack for n elements
      require 
          positive_capacity: n >= 0
      do 
          capacity := n
          !!representation.make(1, capacity)
      ensure
          capacity_set: capacity =n
          array_allocated: representation /= Void
          stack_empty: empty

feature -- access
      capacity: INTEGER
                -- Maximum number of stack elements
      count: INTEGER
                -- number of stack elements
      item: G is
                --tip element
          require
              not_empty: not empty -- i.e. count > 0
          do
              Result := representation @ count
          end

#+end_example
#+latex: \end{listing}
STACK2 is templated on type =G= and provides a constructor =make=,
accessor methods =capacity=, =count= and =item= as well as methods
not shown here for brevity: =empty=, =full=, =put= and =-remove=.
The aspect of interest t us at this stage are the =require= and
=ensure= clauses which provide a series of named assertions about the
inputs to and outputs from the functions.

 
Inheritance and the Liskov Substitution Principle (LSP) \cite{lsp} are
supported through the respective weakening and strengthening of pre
and post conditions in derived classes. A derived method may require
no more, and promise no less, than its parent. 

Eiffel contracts are implemented in terms of assertions, similar to
those found in the C family of languages. In practice Eiffel
assertions are generally restricted to simple checks on field and
parameter values.  Function calls are permitted though Meyer argues
\cite[p.\ 402]{oosc} that such functions should be kept simple and
"beyond reproach".  Practically speaking this means that significant
side effects must be avoided.  Significant? The practice of adding
debug print statements is wide spread, particular in the case of a
failed assertion.

With Meyer's strongly object oriented approach, contracts are enforced
when calling the public methods of an object. Calls internal to an
object neither invoke the contracts nor trigger invariant checks.

In line with Parnas' assertion that contracts should be readily
available to the developer, Meyer provides a tool which generates a
short form of his class descriptions; essentially an interface
specification.  This short form includes the pre and post conditions.



** JML

JML \cite{jml} provides a Design by Contract framework for Java.  Much
of the functionality is similar to that introduced in Eiffel: pre and
post conditions are provided for class methods and inheritance is
supported through the respective  weakening and strengthening of those
pre and post conditions. The exact nature of the refinement of pre 
and post conditions differs from that in Eiffel \cite{toth10}.  We
discuss this in section  \ref{meta}.

JML is written in terms of annotations embedded in the comments of the
Java program \cite{jmlc}.  These comments are then processed by =jmlc=
which generates a wrapper class to enforce the contract and delegates
the implementation to the native java code.  The use of annotated
comments simplifies the implementation of =jmlc=: it just has to
pre-process the annotations and generate legal java which is then
compiled as usual.  Unfortunately it has the disadvantage that the
usual productivity tools associated with a modern development
environment: syntax highlighting, auto-completion etc. are no longer
available. To the tool, the JML markup appears to be simply comments
and is processed as such.

A distinctive aspect of JML, in contrast to Eiffel, is its support for
model based specification based on the work in Larch
\cite{Guttag:1993:LLT:151155}. An abstract model of the system is
constructed in the JML annotations and its representation checked
against that of the underlying implementation. Data, albeit meta-data,
may be modified in a contract. This is in contrast to the assertion
mechanisms of the C family of languages where assertions should never
have significant side effects.  The intent is to provide a meta-data
model of the underlying implementation.  Contract conditions may then
adjust this meta-data model to track what should be happening in the
implementation.





** Microsoft CLR

An interesting development over the last few years has been the rise of
the virtual machine as a platform on which to build programming
languages.  Arguably the two dominant players are Microsoft's Common
Language Runtime (CLR) and the Java Virtual Machine (JVM).

Microsoft has implemented a version of Eiffel's contract checking in
the CLR \cite{msft-contract},\cite{ECL}.  Interestingly this provides
both run time and static checking.  Perhaps because this feature in
not enabled by default in the Visual Studio IDE, usage appears to be
very low.

** Contracts in functional languages
The simple parameter and return value checking that follows from
Parnas' work has proved useful in the procedural world.  Its utility
is severely reduced in functional programming paradigms where
functions are passed around as first class objects.  It is no longer
possible to simply examine the arguments to a function at call time to
know if they satisfy the pre condition.


Although the absence of higher order contracts has been noted by the
functional community, it is also of significance in the procedural and
object oriented communities.  Even in C, function pointers can be
passed so it could be advantageous to attach a contract to those
functions.  In object oriented paradigms, patterns such as the Command
Object \cite{gof} allow a closure to be passed to a method for later
processing; again a candidate for high order contract checking.


Racket, previously known as PLT Scheme, has taken on the idea of
contracts. Contracts in Racket are separated from the function 
definition in a module exports section \cite{racket}. This allows
contracts to be enforced only at module boundaries.  Calls to a
function within the module do not undergo contract checking.  This
follows the premise of Eiffel \cite[p.\ 366]{oosc}.


# introduces the concept of =any= and =any/c=.  Can be used to state
# that any integer can be returned etc.

The Racket implementation is based on the work of Findler and
Felleisen \cite{hof} who state that: "Contracts are either simple
predicates or function contracts.  Function contracts, in turn,
consist of a pair of contracts [\ldots] one for the domain of the
function and one for the range of the function."
It is this recursive approach to contracts which allows the use of
higher order functions --- higher order contracts cannot be enforced until
some function consumes or produces only first order values.

Central to their implementation of contracts for higher order functions
is the meta function, =wrap= which wraps the underlying function
implementation.  If the contract is a simple predicate, it is
evaluated. Higher order contracts consist of two terms: a pre- and
post- condition, each of which in turn may be first or higher order.
For these higher order contracts, =wrap= is recursively applied to the
higher order term.

\cite{hof} also investigates blame assignment.  Whilst knowing that a
program is faulty is helpful, knowing where the fault lies is more
useful.  \cite{hof} introduces the concept of positive and negative
positions in the =wrap= function.  Initially these are applied to
caller and called function. Should a first order contract fail the
positive location is blamed.  Higher order contracts have the positive
and negative locations swapped before the recursive application of
=wrap=.


# higher order contracts described in
# file:./papers/contracts-as-projections.pdf


Hinze et al.\cite{citeulike:661450} extend the work of Findler and
Felleisen, introducing a Domain Specific Language to support the
description and composition of contracts.  Again a focus of this work
is on refining the blame assignment in the event of a contract failure.
Whilst is helpful to know of the existence of a bug in your program,
knowledge as to where in the program the bug exists is even more
valuable.  Findler and Felleisen track at most two locations for blame
assignment. When contracts are being applied to higher order functions,
this necessitates discarding dependent contract location data and
replacing with the current contract's location data.  Hinze et al.
provide a pair of stacks of locations.  For a first order function
this simplifies to the Findler and Felleisen model, but carries
additional information for higher order functions.



* A brief introduction to Clojure

Clojure, first introduced in 2007, is according to its inventor:

\begin{quote}
\begin{itemize}
\item A Lisp

\item for functional programming

\item symbiotic with an established platform

\item designed for concurrency \cite{rationale}
\end{itemize}
\end{quote}

I chose to use Clojure as the platform for my investigation of Design
by Contract in part because of Lisp's flexibility for such experiments
and in part through a desire to get to know Clojure better: my
professional work developing video conferencing infrastructure was
repeatedly showing the need for multi-core concurrency and the ability
to integrate easily with a large body of sophisticated and specialised
libraries. Being built on the Java Virtual Machine (JVM), Clojure has
outstanding access to libraries and is designed with concurrency in
mind.

Clojure is a member of the Lisp family of languages whose common
ancestor was invented by John McCarthy in 1958 \cite{lisp}.
Various flavours of Lisp have hovered around, but never quite broken
into, the mainstream software development world. Lisps have played a
significant role in research into areas such as artificial
intelligence \cite{paip} and object oriented programming
\cite{kiczales} where the simplicity of the core language
\cite{roots-of-lisp} combined with its colonising approach to new
paradigms makes it a powerful vehicle for experimentation.


** Anatomy of a Clojure program
 
Like other Lisps, Clojure programs are built from sexprs (symbolic
expressions) where a sexpr is either an atom, e.g. the integer =42=,
or an expression of the form 
\begin{texttt}(x\space.\space{}y)\end{texttt}  
where =x= and =y= are themselves sexprs.  The notation 
\begin{texttt}(x\space.\space{}y)\end{texttt}  
denotes a cons cell, terminology derived from the Lisp function used
to construct it.  It represents an ordered pair of values and is
typically used to build linked lists.  In such a case the second value
(known as the =cdr= of the cell) points to the next cons cell.  Proper
lists are terminated when the =cdr= is nil. Figure \ref{fig:cons}
shows the construction of a proper list 
\begin{texttt}((x\space.\space{}y)\space{}.\space{}nil)\end{texttt} 


# cons cell diagram
\begin{figure}
\centering
\usetikzlibrary[arrows]
\begin{tikzpicture}
      \node (xcar) at ( 0,2) [shape=rectangle,draw, minimum size = 10mm] {};
      \node (xvalue) at ( 0, 0) {x};
      \node (xcdr) at ( 10mm, 2)  [shape=rectangle,draw, minimum size=10mm] {};
      
      \node (ycar) at (40mm, 2) [shape=rectangle,draw, minimum size = 10mm] {};
      \node (ycdr) at (50mm, 2) [shape=rectangle,draw, minimum size = 10mm] {};
      \node (yvalue) at (40mm, 0) {y};

      \node (nil) at (80mm, 2) {nil};

      \draw[ *->] (xcar.center) -- (xvalue);
      \draw[ *->] (xcdr.center) -- (ycar);
      \draw[*->] (ycar.center) -- (yvalue);
      \draw[*->] (ycdr.center) -- (nil);
\end{tikzpicture}

\caption{Lisp cons cells and lists}
\label{fig:cons}

\end{figure}

Since lists form the basic building block of the language, and are
thus very common, a short hand notation is provided. The proper list
\begin{texttt}((x\space.\space{}y)\space{}.\space{}nil)\end{texttt} 
is usually represented as 
\begin{texttt}(x\space{}y)\end{texttt}.

Sexprs which may be evaluated are known as forms.  With a few
exceptions described later, the processing rules assume that the first
element of the form is a function and apply that function to the
subsequent elements of the form.  Lisps follow strict semantics so
function arguments are evaluated before the function itself
\cite{nonstrict}.  

#+begin_src clojure
(+ 1 2 (* 2 3))
9
#+end_src 


The processing exceptions mentioned above are known as "special
forms". There are a number of these which do not obey the usual
processing rules.  Consider for example an =if= statement:

#+begin_src clojure
(if (< 1 2)                         ; 1
  (print "Normal maths applies")    ; 2
  (print "Strange maths applies"))  ; 3
#+end_src

The intent is that, if the test on the first line is true execute line
2, otherwise line 3.  Following the rules described above we need to
evaluate all the arguments to =if= before passing them to the form.
This would result in two, contradictory, messages being printed.  The
lack of support for non-strict semantics in Clojure means that we need
to make =if= an exception to the normal processing rules: a special
form.

One significant special form is =(quote (...))=, usually abbreviated
to ='(...)=.  A quoted form prevents its argument being evaluated at
all:

#+begin_src clojure
'(foo 1 2) ; foo has not been defined

> (foo 1 2)
#+end_src


TODO #' and #" syntax

** Other data structures

Classical Lisps use lists, =(...)= as their data structure of
choice.  Clojure extends the code-as-data system to include maps and
vectors.  This means that the reader, that part of the system
responsible for parsing the input, prior to evaluation, has innate
knowledge of these structures, allowing them to be used in the macro
system described later.

Maps, similar to Python's dictionaries, are a sequence of key value
pairs.  

#+begin_src clojure
(def map-example {"one" 1 "two" 2})
#+end_src

As a map is also a valid function, map lookup may be performed using
the key:

#+begin_src clojure
(map-example "one")
 > 1
#+end_src

Clojure also supports vectors as a first class data structure, indeed
it is the data structure of choice in many cases such as passing
arguments to a function.  Denoted by =[...]=, they too are a valid
function:

#+begin_src clojure
(def vector-example [10 20 30 40])
(vector-example  2)
> 30
#+end_src

** Macros


All Clojure programs consist of lists of sexprs.  This homoiconicity
of Lisps, the fact that the program text itself forms a valid Lisp
data structure, is central to the power of Lisp's - and Clojure's -
macro system. The full power of the language is available to
manipulate the data structures that form the program
text. Unfortunately the use of the name "macro" for this aspect of the
language can cause confusion with the well known, and usually
disliked, C =#define= macro system.  It is worth emphasising that,
whilst C macros provide basic textual substitution in a pre-processor,
a Lisp macro is operating not on the text but on a data structure
created from the parsed text.  A better comparison would be that Lisp
macros provide a more powerful, and readable, version of C++ template
meta programming.  Macros are run and generate code at macro expansion
time.  That code and any other regular code is then executed at run
time.

At their simplest macros make use of the backquote special form.  In a
similar manner to the =quote= special form, the body of a backquote
expression is emitted verbatim.  Unlike the =quote= syntax, individual
elements of the body can be executed by preceding with a =~=.  The
following macro emits code to sum the macro arguments:

#+begin_src clojure
(defmacro pointless-summation [a b]
  `(+ ~a ~b))

(pointless-summation 3 4)
#+end_src

The generated code can be examined using =macroexpand= which reveals
that the above expands to:

#+begin_src clojure
(clojure.core/+ 3 4)
#+end_src

This is the code which will be executed at run time. A full
explanation of macros is beyond the scope of this dissertation,
\cite{Seibel} is recommended as a starting point.


The Lisp macro system  allows much of Lisp to be written in
terms of itself; there is a very restricted set of special forms which
provide functionality which cannot be obtained by following the
standard evaluation rules.  This is the case with Clojure; whilst the
deep internals of the language are written in Java, the majority of
the language is written in terms of Clojure itself.  For example
anonymous functions may be introduced with =fn=.

#+begin_src clojure
(fn [n] (+ 3 n))
#+end_src

=defn=, \label{defn} the symbol usually used to introduce a named
function definition, is written in terms of =fn=: =(def name (fn
[params* ] exprs*))=, where =def= is a special form which defines a
symbol, an association of a name and a =var=.  There is also a variant
of =defn=, =defn-= which is used to define functions private to the
current namespace.

A typical use of =defn= would be:

#+srcname:unchecked-java-sqrt
#+begin_src clojure  
(defn unchecked-java-sqrt
  "Return the square root of n, calling the underlying 
   Java implementation"
  [n]
  (Math/sqrt n))
#+end_src

Clojure allows an optional documentation string as the first argument
following the function name.  This documentation may be accessed as:
=(doc unchecked-java-sqrt)=.  Clojure development typically takes
place with access to a REPL - an interactive shell which Reads the
user's input, Evaluates it, Prints the result and Loops.  This
interactive, exploratory, approach to software development is typical
of Lisp development. Programmatic access to documentation is therefore
very convenient.



The use of macros to build layers of functionality on top of the core
implementation, the ability to treat the program as data, makes Lisp
an attractive language in which to experiment when we wish to modify
the behaviour of the language itself.


*** Clojure's built in pre and post conditions

The usual way of introducing a function into a Clojure environment,
=defn= is a macro which can accept pre and post conditions..
#+begin_src clojure :exports none
(macroexpand '(defn checked-java-sqrt 
                "Pre Condition checks prior to calling underlying function"
                [n]
                {:pre [(number? n) (>= n 0)]}
                (Math/sqrt n))) 
#+end_src

Macro expansion, prior to compilation, wraps the body of the =defn= in
assertions validating the pre and post conditions.  It is this
augmented body which is compiled to form the function. 

Omitting meta data, macro expansion of =checked-java-sqrt= yields:
#+begin_src clojure
(fn* checked-java-sqrt 
     ([n]
	(clojure.core/assert (number? n))
	(clojure.core/assert (>= n 0))
	(Math/sqrt n)))
#+end_src

This provides basic condition checking, allowing us to define a new
version of =java-sqrt=


#+srcname: checked-java-sqrt
#+begin_src clojure
(defn checked-java-sqrt 
  "Pre Condition checks prior to calling underlying function"
  [n]
  {:pre [(number? n) (>= n 0)]}
  (Math/sqrt n))
#+end_src


Should the pre condition be violated, a Java =AssertionError=
exception will be thrown which can be handled in Clojure in the normal
manner:


#+begin_src clojure 
(try (print (checked-java-sqrt -1))
     (catch AssertionError e
       (.getMessage e)))
#+end_src


Will result in:

#+results:
: Assert failed: (>= n 0)


#+srcname: contracts
#+begin_src clojure :tangle hello.clj :exports none :noweb yes
  <<unchecked-java-sqrt>>

  <<checked-java-sqrt>>
#+end_src



The demotion of the conditions to generalised assertions loses the
ability to extract the conditions for use in Eiffel style short form
descriptions. Pre or post condition violation can be inferred from
which assertion fails and blame assigned through inspection of the
call stack obtained via =getStackTrace= in the case of pre condition
failure. Though usually robust, it is possible for the JVM to omit
stack frames in order to optimise execution so a violating caller may
not appear in the list of blame candidates.





*** Mutable data

State, mutable data, is at odds with the "designed for concurrency"
goal \cite{rationale} of Clojure.  If two methods use and can
modify the same piece of data then to allow the two methods to run
concurrently requires some form of concurrency control.  Typically
this concurrency control takes the form of a locking strategy: before
modifying mutable data the method must acquire a lock, releasing it
when the operation is complete.  Improper locking strategies --- method
1 acquires lock A, then lock B, method 2 B then A --- can result in
deadlock.  More fundamentally, lock based strategies are not
composable \cite{Harris}: 
\begin{quote} 
Perhaps the most fundamental objection [...] is that lock-based
programs do not compose: correct fragments may fail when
combined. For example, consider a hash table with thread-safe insert
and delete operations. Now suppose that we want to delete one item A
from table t1, and insert it into table t2; but the intermediate
state (in which neither table contains the item) must not be visible
to other threads. Unless the implementor of the hash table
anticipates this need, there is simply no way to satisfy this
requirement. [...] In short, operations that are individually
correct (insert, delete) cannot be composed into larger correct
operations.
\end{quote}

# —Tim Harris et al., "Composable Memory Transactions", Section 2: Background, pg.2

Clojure provides support for mutable data through the use of
transactional references: =ref='s.  Modifications to the data must be
wrapped in a transaction and may be protected by a validator function.
This validator function provides another point at which system
integrity may be verified.  When the validator is called the nature of
the transaction is unknown so method pre and post conditions are
inappropriate but this does provide an ideal point for maintaining
data invariants.

* Design goals for a Design by Contract framework

Clojure provides Eiffel like pre and post condition checking through a
simple assertion mechanism.  But as a functional programming language,
function arguments are often functions themselves.  Simple pre and
post condition assertions can not verify these functional arguments as
the can only be checked when invoked.  

In order to increase the ability to use Design by Contract techniques
in Clojure, we intend to construct a library which provides support
for higher order contract checking based on the work of \cite{hof}.  The
library should be written in terms of Clojure itself and should
allow us to easily view the contracts pertinent to a function.  The
ability to adjust the detailed behaviour of the framework to suit
different usages is also desirable.




* A Clojure implementation

In this section we will be implementing a Design by Contract
framework that supports functional programming.  Two implementations
will be shown and their merits compared.

** Terminology

During development of our Clojure implementation of a
Design by Contract framework.  A number of functions go through an
evolution as the implementation is refined.  Intermediate function
definitions are named with numeric suffices: =myfunc-1=, =myfunc-2=
etc., the final form being =myfunc=.  References in the text to the
entirety of this evolving family of definitions are made as
=myfunc-*=.

** An initial approach

Our initial implementation is based on that described by Findler and
Felleisen \cite{hof}. In Listing \ref{lst:wrap} we define a function, =wrap-1= which
is used to provide validation of a function parameter.  Should the
parameter be first-order, =wrap-1= will trigger an immediate assertion
check.  higher order parameters, i.e.\nbsp a function which will be used
later, are replaced by a new function which wraps the original in a
contract checker.



Should the contract fail, blame will be assigned based on whether the
pre or post condition was responsible.  An error message can be
emitted with the culprit identified appropriately.

#+srcname: preamble
#+begin_src clojure :tangle yes :exports none 
(ns dbc.core
  (:use clojure.test clojure.walk clojure.contrib.condition [clojure.contrib.string :only (substring?)]))
;; Commentary
;; This file is generated from the literate programming sources in
;;  impl.org, use that as the master.

;;
;; All contracts pertain to the arguments to this function so if the
;; argument is a higher order function, then the contract states: "takes
;; a function which returns positive numbers" or some such.

;; So how do we describe that contract?

;; "takes a positive number": (pos ?)
;; "takes a function which returns a positive number": ?



(declare make-contract-1 dom rng flat? lenient strict pred contract-error)





(deftest contract-construction
  (testing "Flat predicate"
    (is (flat? :foo))
    (is (not (flat? (make-contract-1 :foo :bar)))))
  (testing "Contract construction"
    (is (= 4 (count (make-contract-1 :foo :bar))))
    (is ((dom (make-contract-1 lenient lenient)) 42))))







(declare fo-wrap ho-wrap-1)

                                       


#+end_src






#     Mutual recursion, as in ho-warp and wrap, probably ought to
#     use trampolining:
#     http://groups.google.com/group/clojure/msg/3addf875319c5c10


#+latex: \begin{listing}[H]
#+LATEX: \caption{Clojure implementation of \texttt{wrap}}\label{lst:wrap}
#+srcname: wrap1

#+begin_src clojure :tangle yes :exports code
(defn wrap-1 [contract value p n]
  (if (flat? contract)
    (fo-wrap contract value p n)
    (ho-wrap-1 contract value p n)))

(defn- fo-wrap  [contract value p n]
  (if (contract value)
    value
    (contract-error p)))

(defn- ho-wrap-1 [ct x p n]
  (let [d (dom ct)
        r (rng ct)]
    (fn [y] (wrap-1 r
                  (x (wrap-1 d y n p))
                  p
                  n))))

(defn contract-error
  "Signals a contract failure at `position'"
  [position]
  (throw (Exception. (str "Contract failed: " position))))


#+end_src
#+latex: \end{listing}



Findler et al. refer to their version of =wrap-1= as a contract
monitor, we prefer Contract Enforcement Point as "monitor" seems a
somewhat passive description of something which has the ability to
terminate a program.  This also allows the use of Contract Definition
Point for the location in the program text where the contract is
defined.  This emphasises the separation between definition and
enforcement and provides a useful analogue with the terminology used
in policy based management \cite{RFC3198}.


The underlying contract implementation is hidden behind utility
functions shown in Listing \ref{contract-utility}.  We need to select
a data structure to represent the contracts.  As is idiomatic in
Clojure development, the first data structure of choice is =map=.
Here we define two keys, =:dom= and =:rng= to hold the domain and
range (pre and post conditions).  We provide two implementations of
=make-contract-1=: =make-contract-1/2= is a simple shorthand version
which calls =make-contract-1/4= with default values of the message to
be used in the case of pre or post condition failure.

#+latex: \begin{listing}[H]
#+latex: \caption{Contract utility functions}\label{contract-utility}
#+begin_src clojure :tangle yes :exports code
(defn make-contract-1 
  ([pre post]
     (make-contract-1 pre
                      post
                      "Pre condition failed"
                      "Post condition failed"))
  ([pre post pre-message post-message]
     {:dom pre :rng post
      :pre-message pre-message
      :post-message post-message}))

(defn dom [contract]
  (:dom contract))

(defn rng [contract]
  (:rng contract))

(defn flat? [x]
  (not (map? x)))
#+end_src
#+latex: \end{listing}

We also find it convenient to introduce two simple predicates for
testing purposes: =lenient= and =strict=.  The first will allow any
value whilst the second will deny any value.


#+begin_src clojure :tangle yes :exports code
(defn lenient [_]
  true)

(defn strict [_]
  false)
#+end_src


To examine how =wrap-1= works we look first at an Eiffel style first
order contract. We define a faulty single parameter function which
requires its argument to be positive and guarantees its return value
is also positive.


#+latex: \begin{listing}[H]
#+latex: \caption{First order require/ensure implementation} \label{lst:fo}
#+srcname: lst:fo
#+begin_src clojure :tangle yes :exports code
(defn gt0? [x]
  (and
   (number? x)
   (pos? x)))

(def faulty-sqrt
  (wrap-1 (make-contract-1 gt0? gt0?)
          (fn [not-used] -1)
          "Post condition violated" "Pre condition violated"))

(deftest faulty-sqrt-test
  (is (thrown-with-msg? java.lang.Exception #"Post condition"
        (faulty-sqrt 1)))
  (is (thrown-with-msg? java.lang.Exception #"Pre condition"
        (faulty-sqrt 0))))
#+end_src
#+latex: \end{listing}




In Listing \ref{lst:fo} we introduced the predicate =gt0?= to verify
that the argument is both numeric and greater than zero. A naive use
of the predicate =pos?= will cause a =java.lang.ClassCastException= to
be thrown if something other than a number is passed in.  As this
exception will bypass our blame assignment we need to protect against
it.  This form of category error, failing to predicate all possible
argument types that the function may be called with, is easily made
when the programmer is focusing purely on defining the function and
contract at hand.  In normal Clojure development the error would then
be caught either at the REPL or during more formal testing, but that
negates the value of our Design by Contract harness.  We will
therefore wish to provide a library of basic predicates such as =gt0?=
which accept a wider category of inputs.

=faulty-sqrt= demonstrates blame assignment, allowing the user of a
function to determine whether it is the called or calling function at
fault. Calling =(faulty-sqrt 1)= will throw an exception declaring
that the post condition was violated, a fault in the called function,
whilst =(faulty-sqrt 0)= will declare that the pre condition has been
violated, with the caller at fault.


To demonstrate the application of =wrap-1= we use a simple higher order
example  based on section 2.2 of \cite{hof}. Consider a function
=ff-save= which saves a function and =ff-use= which later calls the saved
function, activating its contract.  We wish to constrain =ff-save= to
only accept functions which take and return  numbers greater than 0.  


#+latex: \begin{listing}[H]
#+latex: \caption{Application of \texttt{wrap}} \label{lst:ff-use}
#+srcname: ff-use
#+begin_src clojure :tangle yes :exports code
(def ff-saved (ref (fn [not-used] 50)))



  ;;; (bigger-than-0 -> bigger-than-0) -> any
(defn ff-save [f] (dosync (ref-set
                           ff-saved
                           (wrap-1 (make-contract-1 gt0? gt0?)
                                 f
                                 "p"
                                 "n")) ))


  ;;; bigger-than-0 -> bigger-than-0
(defn ff-use [n] (ff-saved (wrap-1 gt0? n "p" "n")))


(deftest ff-example ;\ref{line:test}
  (ff-save (fn [not-used] 50))
  (is (= 50 (ff-use 42)))
  (is (thrown? java.lang.Exception (ff-use -1)))
  (ff-save (fn [not-used] -1))
  (is (thrown? java.lang.Exception (ff-use 42))))
#+end_src
#+latex: \end{listing}



Listing \ref{lst:ff-use} also adopts the comment contract
specification notation from \cite{htdp} to specify the expected types
of arguments and return values.  But it is the goal of executable
contracts to replace that information in an enforceable way without
the redundancy of unconnected commentary.  We will visit this problem
in section \ref{selfdocumenting}.

The =deftest= of Listing \ref{lst:ff-use} validates our contract
implementation, demonstrating that exceptions are thrown  should
either the argument or return value of the stored function be less
than zero. Similar unit tests are provided for the rest of our
framework implementation but are only show here where they provide a
useful demonstration of function usage.





** Code generation
\label{codegen}
Although logically correct, manually wrapping each occurrence of a
parameter in calls to =wrap-1= is tedious and error prone; the sort of
thing computers were intended to relieve us from.  Clojure, like other
Lisps, has a sophisticated macro system which can be used to
automatically generate this code.  We will be using this macro system
to allow us attach contracts to functions, automatically wrapping the
arguments.  

We will look at two approaches to using macros to apply the wrap
function: we first look at a monolithic approach to the problem
where we define a new macro, =defcontract= which requires access to
the body of the function we are applying contracts to.  We then
examine a second, superior, version where existing functions may have
contracts attached to them, without requiring access to the function body.


*** A monolithic approach

Inspired by an intent to emulate the function definition macro =defn=,
with support for contracts on higher order functions, we construct a
macro =defcontract=.  For simplicity we only consider functions taking
a single argument.

#+latex: \begin{listing}[H]
#+latex: \caption{An initial contract macro} \label{defcontract1}
#+srcname: label
#+begin_src clojure :tangle yes :exports code
(defmacro defcontract-1 [fn-name a c body]
  (let [wrapped-arg {a `(wrap-1 ~c ~a "p" "n")} ] 
    `(defn ~fn-name [~a]
       ~(clojure.walk/postwalk-replace wrapped-arg body))))




#+end_src
#+latex: \end{listing}

Examining what's happening in Listing \ref{defcontract1}: the =let=
line creates =wrapped-arg=, a map holding the original function
argument and its intended replacement. This replacement argument calls
=wrap-1= with both the original argument and its contract. The following
line, starting with 
#+latex: \verb=`=
is the new function definition; forms prefixed with \tilde are
replaced with the result of their evaluation, all other forms are
rendered verbatim.  The function =postwalk-replace= will replace each
occurrence of the original argument with its wrapped equivalent.

The overall result of this macro is to create a function definition
with every use of an argument wrapped in a call to the =wrap-1= function
of Figure \ref{lst:wrap}. 




TODO defcontract-1 or -2?

#+latex: \begin{listing}[H]
#+latex: \caption{ff-save implemented with the contract macro.} 
#+latex: \label{lst:ff-use2}
#+srcname: label
#+begin_src clojure :tangle yes :exports code
(defcontract-1 ff-save-2 f (make-contract-1 gt0? gt0?)
  (dosync (ref-set ff-saved f)))

(defcontract-1 ff-use-2 n gt0?
  (ff-saved n))

(deftest ff-example-2 ;\ref{line:test}
  (ff-save-2 (fn [not-used] 50))
  (is (= 50 (ff-use-2 42)))
  (is (thrown? java.lang.Exception (ff-use-2 -1)))
  (ff-save-2 (fn [not-used] -1))
  (is (thrown? java.lang.Exception (ff-use-2 42))))
#+end_src
#+latex: \end{listing}

As well as checking the argument to the function =fn-name= defined
using =defcontract-1=, we need to verify the return value from the
function.  There are two possible approaches to this: we could use
Clojure's pre-existing post condition check, =:post= discussed previously, or
we could use the =wrap-1= function developed above.  The use of =:post=
checks would limit us to simple flat asserts about the return value,
whereas we would like to still have the ability to check higher order
function returns.  Accordingly we will use =wrap-1= to verify return
values from functions defined using =defcontract-2=


Using this macro we can simplify the definitions of =ff-use= and
=ff-save= from Listing \ref{lst:ff-use} to:

#+latex: \begin{listing}[H]
#+begin_src clojure :tangle yes :export code
(defmacro defcontract-2 [fn-name a c post body]
  (let [wrapped-arg {a `(wrap-1 ~c ~a
                                "post condition of arg"
                                "pre condition of arg")} ] 
    `(defn ~fn-name [~a]
       (wrap-1 ~post 
               ~(clojure.walk/postwalk-replace wrapped-arg body)
               "Post condition of function return"
               "Pre Condition of function return"))))


(defcontract-2 ff-save-x f 
  (make-contract-1 gt0? gt0?)
  lenient
  (dosync (ref-set ff-saved f)))

(defcontract-2 ff-use-x n
  gt0?
  lenient
  (ff-saved n))



(deftest ff-example-x ;\ref{line:test}
  (ff-save-x (fn [not-used] 50))
  (is (= 50 (ff-use-2 42)))
  (is (thrown? java.lang.Exception (ff-use-x -1)))
  (ff-save-x (fn [not-used] -1))
  (is (thrown? java.lang.Exception (ff-use-x 42))))

#+end_src
#+latex: \end{listing}

*** A modular approach
The macro defined in Figure \ref{defcontract1} successfully automates
the process of wrapping function parameters in contract checking
code. Unfortunately the resulting code is monolithic; conflating
function implementation and contract.  This dramatically reduces
modularity - one of the key advantages of functional programming
\cite{hughes}. When used for functions like the =sqrt=
example this is not too disastrous: the contract is a consequence of
the underlying mathematics of the implementation.  But if we need
similar contracts for other functions reuse will be limited.  In some
cases contracts will be used to impose business rules on a function,
rather than implementation artefacts.  In those cases we may wish to
reuse the function implementation with a different contract in an
alternative environment.

Ideally a contract should just be an aspect of the function, along
with its implementation.  Aspect Oriented Programming has been used
\cite{aopdbc} to implement Design by Contract in AspectJ.  We're
seeking to develop a similar approach where the contract and
underlying function implementation can be specified separately and
combined at will.   


We therefore consider an alternative approach where we
produce a function which acts a facade to the original: calling it
with its argument list replaced by arguments which have been protected
by calls to the =wrap= function described above:

#+BEGIN_SRC clojure :tangle no :exports code
(defn wrapit [myfn arg contract]
  (myfn (wrap contract arg "post" "pre")))
#+END_SRC

Whilst we could manually create these facades for all of our
contracted functions, that would involve a lot of repetitive boiler
plate coding.  This is where Lisp macros are useful.  The =wrapit=
function above provides an example of the output we wish, so we use
that to design our macro.

We will also be extending our approach to handle functions of more
than one argument.  In order to do this we must modify the =ho-wrap-1=
function we have been using. =fo-wrap= remains as before.  Previously,
as seen in Listing \ref{lst:wrap} =ho-wrap-1= has been returning a
lambda function of arity 1.  We now wish to handle an arbitrary number
of arguments.  Whilst it is not in general possible to determine the
arity of a Clojure function, in this case we may assume that the
number of contracts in the domain represents the arity.  We therefore
wish to generate a lambda function with a argument for each domain
contract.  Now we see an benefit of Clojure's dynamic typing: we do
not need to modify =make-contract=, instead we just pass a vector of
domain contracts as the first argument to that function.

#+latex: \begin{listing}[H]
#+latex: \caption{Wrapping functions with multiple arguments}\label{ho-wrap} 
#+BEGIN_SRC clojure :tangle yes :exports code
(declare ho-wrap)

(defn wrap-x [contract value p n]
  (if (flat? contract)
    (fo-wrap (get contract 0) value p n)
    (ho-wrap contract value p n)))


(defn ho-wrap [ct x p n]
  (let [d (dom ct)
        r (vector(rng ct))
        arity (count d)]
    
    (cond
      (= 0 arity)
      (fn [] (wrap-x r
                   (x)
                   p
                   n))
      (= 1 arity)
      (fn [a] (wrap-x r
                      (x (wrap-x (vector (get d 0)) a n p))
                    p
                    n))
      (= 2 arity)
      (fn [a b] (wrap-x r
                        (x (wrap-x (vector (get d 0)) a n p)
                           (wrap-x (vector (get  d 1 )) b n p))
                        p
                        n)))))


#+END_SRC
#+latex: \end{listing}



We forward declare a pair of functions: =wrap-arg-contract= will
apply wrap to an argument and contract extracted from a list;
Clojure's de facto pair representation; =zip= will produce a list of
such pairs from two separate lists.  Implementation of these two will
follow once we have examined the main =attach-contracts= macro.  Once
the code is fully presented we will look at the macro expansion from
a simple use and compare the generated code to that of =wrapit= above.

#+latex: \begin{listing}[H]
#+latex: \caption{A modular approach to applying contracts}\label{attach-contracts} 
#+BEGIN_SRC clojure :tangle yes :exports code
(declare wrap-arg-contract zip)

(defmacro attach-contracts [newname func contracts]
  "Create a new function definition `newname' which calls
  `func' with the args stored in arg/contracts wrapped in
   the corresponding contract."
  (let [args (vec (map gensym  (range (count contracts))))]
    `(defn ~newname ~args
       (let [wrapped-args# 
             (map wrap-arg-contract (zip ~args ~contracts))]
         (apply ~func wrapped-args# )))))


#+END_SRC
#+latex: \end{listing}

As before, this emits a function definition.  The difference to that
in the =defcontract= macro is that in the last line the call to
=apply= invokes a function call with wrapped arguments.  The =let=
line of the implementation constructs a vector to be used as the
argument list in the the newly defined function.  There will be as
many arguments as there were contracts passed in to the call to
=attach-contracts=.  In order to build this vector we map =gensym=
over the =contracts= vector.  Invoking =gensym= will return a new
symbol with a unique name so =args= will be a vector of such symbols;
ideal for use as an argument list.  One minor convenience has been
added: =gensym= generates names using the string representation passed
to it.  As we are running this code at compile time, that string is
the vector of contracts.  Applying =gensym= directly to that generates
names such as =[gt0?]3456= which I found difficult to read correctly
when debugging, interpreting the name as a vector.  To simplify this
we generate a range over the number of contracts and use that as the
input to =gensym= resulting in much more readable, all numeric,
names. Finally, in the =defn= line, =~newname= is replaced by the =newname=
parameter passed in to the macro and =~args= by our newly created
vector of symbols.


#+latex: \begin{listing}[H]
#+latex: \caption{Supporting functions for attach-contracts}
#+BEGIN_SRC clojure :tangle yes :exports code
(defn wrap-arg-contract [arg-contract]
  "Extracts the contract from the pair arg-contract and returns
   arg wrapped in that contract"
  (let [arg (first arg-contract)
        contract (second arg-contract)]
    (wrap-x contract arg
          (:post-message contract)
          (:pre-message contract))))


(deftest wrap-test 
  (is (= 4
         (wrap-arg-contract (list 4 [gt0?]))))
  (is (thrown-with-msg? java.lang.Exception #"Contract failed"
        (wrap-arg-contract (list 0 [gt0?])))))


(defn zip
  "Returns a lazy sequence consisting of pairs made of the first
  elements of a and b, second etc."
  [a b]
  (map list a b))


(def faulty-sqrt-2
  (wrap-arg-contract (list (fn [not-used] -1)
                           (make-contract-1 [gt0?] gt0?))))

(deftest faulty-sqrt-2-test
  (is (thrown-with-msg? java.lang.Exception #"Post condition"
        (faulty-sqrt-2 1)))
  (is (thrown-with-msg? java.lang.Exception #"Pre condition"
        (faulty-sqrt-2 0))))


#+END_SRC
#+latex: \end{listing}


Considering the trivial case of a function which adds its two
arguments, but requires them both to be positive.  We define a simple
=add-args= function to perform the arithmetic and then call
=attach-contracts= to give a new function, add-args-c,  which imposes
=gt0?= on the two arguments.


#+BEGIN_SRC clojure :tangle yes :exports code
(defn add-args [a b]
  (+ a b))

(attach-contracts add-args-c
                  add-args
                  [ [gt0?] [gt0?] ])

(deftest add-args-test
  (is (= 8
         (add-args-c 4 4)))
  (is (thrown-with-msg? java.lang.Exception #"Contract failed"
        (add-args-c 0 4))))

#+END_SRC



To understand what the =attach-contracts= macro is doing we can use
clojure's pretty print and macroexpand functions to see the code
which is generated at compile time:

#+latex: \begin{listing}[H]
#+latex: \caption{Macro expansion of attach-contracts}\label{macroexpand} 
#+BEGIN_SRC clojure :tangle no :exports code 
(clojure.pprint/pprint (macroexpand-1
                        '(attach-contracts
                          add-args-c
                          add-args
                          [gt0? gt0?])))

=>

(clojure.core/defn
 add-args-c
 [02768 12769]
 (clojure.core/let
  [wrapped-args__2626__auto__
   (clojure.core/map
    dbc.core/wrap-arg-contract
    (dbc.core/zip [02768 12769] [gt0? gt0?]))]
  (clojure.core/apply add-args wrapped-args__2626__auto__)))

#+END_SRC
#+latex: \end{listing}

We see from Listing \ref{macroexpand} that the macro expansion of
=attach-contracts= emits code for the function definition of
=add-args-c=.  We see in the last line of the expanded macro a call to
=apply= which causes the original =add-args= function to be called
with arguments formed by wrapping the arguments passed to
=add-args-c=.


Considering now higher order functions, we will use the example
of =invoke-two-arg=, a function which takes as its single parameter 
a function of arity two.  It applies this function to fixed arguments.
We also introduce =two-arg-contract= which will constrain the function
parameter definition: it will take any arguments but must return a
number greater than zero.


#+BEGIN_SRC clojure :tangle yes :exports code

(defn- invoke-two-arg [f]
  (f 1 2))

(def two-arg-contract (make-contract-1 [lenient lenient] gt0?))

(attach-contracts two-arg-c invoke-two-arg [two-arg-contract])

(deftest two-arg-test
  (is (= 3 (two-arg-c +)))
  (is (thrown-with-msg? java.lang.Exception #"Post" (two-arg-c -))))

#+END_SRC



As we can see from the test harness, =+= will satisfy the contract
whilst =-= fails to maintain the post condition.

Compare this with a function which takes two arguments, the second of
which obeys =two-arg-contract=:

#+BEGIN_SRC clojure :tangle yes :exports code
(defn- two-by-two [ a f]
  (f 1 2))

(attach-contracts two-by-two-c two-by-two [[lenient] two-arg-contract])

(deftest two-by-two-test
  (is (= 3 (two-by-two-c 0 +)))
  (is (thrown-with-msg? java.lang.Exception #"Post"
        (two-by-two-c 0 -))))

#+END_SRC




** Blame assignment
In order to assist the debugging process we wish to able locate the
code involved in contract failures.  Our intent is to provide that
information in the same format as produced by tools such as gcc so
that other development tools can easily utilise the data, perhaps
taking the user to the corresponding file. File and line information
is available in Clojure, but accessing it will require a short tour of
some of the language's internals.

A basic building block of Clojure is the =var=.  From
clojure.org/vars: "Vars provide a mechanism to refer to a mutable
storage location that can be dynamically rebound (to a new storage
location) on a per-thread basis. Every Var can (but needn't) have a
root binding, which is a binding that is shared by all threads that do
not have a per-thread binding. Thus, the value of a Var is the value
of its per-thread binding, or, if it is not bound in the thread
requesting the value, the value of the root binding, if any."

Vars are created using the =def= special form: =(def name value)=
which also creates a metadata map including entries for =:file= and
=:line=.  Of interest to us is the fact that a function definition
=(defn name [params*] exprs*)= is equivalent to defining a var =name=
as =(def name (fn [params* ] exprs*))=.  We therefore have access to
the file and line in which a function is defined. This is the
information we wish to present to our users.  To provide an accessor
to this information we use the following macro:

#+latex: \begin{listing}[H]
#+latex: \label{lst:source-loc}
#+srcname: label
#+begin_src clojure :tangle yes :exports code


(defmacro loc [sym] `(format "%s:%s"
                             (:file (meta (var ~sym)))
                             (:line (meta (var ~sym)))))
#+end_src
#+latex: \end{listing}


As before, the backquoted form is inserted verbatim, except that
\tilde escaped forms are evaluated before insertion.  The =var=
special form returns the Var object (not the value) that =sym= refers
to, and =meta= in turn accesses the metadata of the Var object.  We
are forced to use a macro rather than function call here because =var=
requires a symbol which refers to a Var whilst a function argument is
a symbol whose value will refer to a Var object - an extra level of
indirection.

Although we now have access to the location of the contract which
failed, we have little information available about how we got there.
In the event of a failed contract, we wish to be able to report the
sequence of events which lead up to the failure.  This is typically
achieved through a stack trace: a description of the function call
stack. Clojure's ability to call Java methods directly allows us to
access the function call stack as shown in Listing \ref{stacktrace}


#+latex: \begin{listing}[H]
#+latex: \caption{Stack trace} \label{stacktrace}
#+srcname: label
#+begin_src clojure :tangle yes :exports code

(defn ignored? [classname]
  (let [ignored #{"callers" "dbg" "clojure.lang" "swank" "eval"}]
    (some #(substring? % classname) ignored)))

(defn callers []
  (let [fns (map #(str (.getClassName %))
                 (-> (Throwable.) .fillInStackTrace .getStackTrace))]
    (vec (doall (remove ignored? fns)))))

#+end_src
#+latex: \end{listing}

A brief explanation of Clojure's syntax here: =(.method object args)=
is syntactical sugar for a Java call =object.method(args)= so the
=callers= function above creates a new =Throwable= object and
populates its stack trace: a typical Java solution to the problem.
The final line of =callers= prunes the stack trace, removing function
calls which are an artefact of the development environment.

For first order contracts this provides a good solution: the contract
will be evaluated at the same time that it is applied.  In the event
of failure a stack trace can be generated, describing the sequence of
events, on this thread at least, which resulted in the contract
violation.  Things are not so simple for higher order contracts.  The
contract is not evaluated at the time it is applied but rather
deferred until the contracted function is executed.  The stack trace
at contract evaluation time gives little information about the state
of the program at the point the contract was applied, so we need to
generate the stack trace at contract application time.

Unfortunately here we face a potential performance impact.  Because of
the delayed contract checking of higher order functions, we don't know
at the time we apply a contract whether or not that contract will be
fulfilled and hence whether or not the stack trace will be needed.
Accordingly we must generate a stack trace for every contract
application: a potentially expensive process.  

An alternative would be to modify our function definitions so that
they automatically maintain a call stack, pushing themselves on when
the function is entered, popping off on function exit.  The problem is
that we wish to add stack trace ability to all (or at least most)
functions, not just those we have written to enforce contracts. So we
wish to modify the behaviour of existing code without having to modify
the source of each function: very much the world of Aspect Oriented
Programming (AOP).  Much of the early work on AOP was conducted in
Common Lisp \cite{kiczales-aop} so although Clojure does not provide
direct support for AOP, we can reproduce many of its features.  In
particular, the ability to rebind vars allows us to build simple
kinded point cuts, i.e. our advice code can be run before and after
execution of the original function.  Inspired by an example of adding
trace code \cite{trace}, we can query a namespace for all its functions
and then rebind those to a version which maintains a call stack and
calls the original version.

#+latex: \begin{listing}[H]
#+latex: \caption{Call stack} \label{callstack}
#+begin_src clojure :exports code
(def *call-stack* (var ()))

(defn callstack-ns
  "ns should be a namespace object or a symbol."
  [ns]
  (doseq [s (keys (ns-interns ns))
          :let [v (ns-resolve ns s)]]
    (intern ns
            s
            (let [f (deref v)]
              (fn [& args]
                (binding [*call-stack* (cons s *call-stack*)]
                  (apply f args)))))))

#+end_src
#+latex: \end{listing}
=doseq= is intended for side effects.  It repeatedly executes its body
for a filtered list of its arguments.  In this case we call it for all
functions defined in the given namespace. The body of the =doseq=
replaces the original function with one which places its name on the
dynamic scoped variable =*call-stack*=.  The prefix and suffix =*= are
in the name have no significance beyond being a conventional notation
for dynamic scope. Having pushed the current function name on to the
stack, the original function is called.  On exiting the scope of
=binding=, =*call-stack*= reverts to its previous value.  Thus we
maintain a call stack for the current thread.

** Contract Documentation
\label{selfdocumenting}
TODO To be completed - brief description of contracts as meta data to
function, functions to print that meta data

As with the original definition of Design by Contract \cite[p.\ 389]{oosc}, we
wish to ensure that our contract observing functions are self
documenting.  Eiffel provides a short form documentation tool which
includes contract information.  Clojure has the =doc= function which
will print the documentation meta data associated with a function.
We will provide a simple =contracts= function which will print
=:contract= meta data.

#+begin_src clojure :exports code
(defn contracts [f]
    (println " " (:contract (meta f))))
#+end_src

We now have to store some useful information in the =:contract= meta
data.  Requesting a developer to perform additional documentation
tasks is typically an unrewarding activity so we make use of the
contract definitions passed in to the call =attach-contracts= and
simply store these in string form as function meta data.  To do this
we use the reader meta data macro =#^=.

#+begin_src clojure :exports code
(defmacro attach-contracts-x [newname func contracts]
  "Create a new function definition `newname' which calls
  `func' with the args stored in arg/contracts wrapped in
   the corresponding contract."
  (let [args (vec (map gensym  (range (count contracts))))]
    `(defn ^#{:contracts ~contracts} 
       ~newname ~args
       (let [wrapped-args# 
             (map wrap-arg-contract (zip ~args ~contracts))]
         (apply ~func wrapped-args# )))))
#+end_src


** Meta Framework

So far we have made a number of assumptions about how the framework
will be used.  Some of these, such as our contract violation reporting
mechanism =contract-error=, will be inappropriate for many users.
Taking inspiration from the CLOS Meta Object Protocol \cite{kiczales},
we look for points of variation and introduce the ability to adapt our
framework to a user's needs.

The first and most obvious variation point is the action to
undertake in the event of a contract violation.  Appropriate behaviour
depends on the application, state of development (developer build or
customer release) and the error philosophy of the development team.
More interestingly, different parts of the program may require
different error handling.  McConnell \cite[p.\ 103]{codecomplete} takes the
example of a spreadsheet program where failures in the screen refresh
code should be handled differently to failures in the underlying
calculation engine.  A similar claim that runtime contract failure
should be customisable is made for Microsoft's recent contract
framework \cite{ECL}.

We have already seen in Section \ref{callstack} how Clojure's dynamic
variables provide the ability to rebind a variable.  This is distinct
from simply shadowing the original; shadowing will mask a variable
within the lexical scope of the shadow whilst rebinding provides the
dynamic scope which we need to allow us to pass closures around as
first class objects.  When a contract was applied to a parameter, a
harsh contract failure penalty may have been in place, but when we
come to use the parameter it may be that the penalty for failure has
been relaxed in which case a closure over a lexical scope would give
unwanted behaviour. This is similar to the common library problem
\cite{8ways} where the application developer does not wish to be
constrained by the error reporting mechanism of the library developer.



#+latex: \begin{listing}[H]
#+latex: \caption{Customising failure behaviour} \label{lst:contract-failure}
#+begin_src clojure :tangle yes :exports code
(defn simple-contract-error [position]
  (throw (Exception. (str "Contract failed: " position))))

(def ^{:doc "Function to call on failure of a contract"}
  ,*contract-failure-function* #'simple-contract-error)

(defn contract-error [position]
  (*contract-failure-function* position))


#+end_src
#+latex: \end{listing}

Listing \ref{lst:contract-failure} shows such a rebinding in use.
=*contract-failure-function*= is called on failure.  The programmer
can bind this symbol to a function providing the required behaviour.
The =*= decoration on the function name, often called ear muffs, is
purely a conventional notation to denote a dynamic variable.

We \label{meta} could use different implementations of =contract-error= to generate
the expensive stack traces of Listing \ref{stacktrace} or a simpler,
but less informative implementation.
  

\cite{citeulike:661450} extends the blame assignment of \cite{hof} to
provide additional information about those responsible for a contract
violation.  Given that we now know of two plausible implementations of
blame assignment, this makes another good variation point to allow for
future extension.


#+latex: \begin{listing}[H]
#+begin_src clojure :tangle yes :exports code
(defn combine-loc-ff [l1 l2]
  (take 2 (flatten (vector l1 l2))))
#+end_src
#+latex: \end{listing}

This implementation makes it clear that we discard information: only
the first two elements of the combined location are preserved.  The
version of \cite{citeulike:661450} preserves all locations
accumulated to date which we can implement simply by discarding the
truncating =take=.

#+latex: \begin{listing}[H]
#+begin_src clojure :tangle yes :exports code
(defn combine-loc-hjl [l1 l2]
  (flatten (vector l1 l2)))
#+end_src
#+latex: \end{listing}

In =combine-loc-hjl=, we provide a default implementation and an
implementation of their $\rightslice$ operation which combines
locations, interchanging positive and negative locations when
necessary.

#+latex: \begin{listing}[H]
#+begin_src clojure :tangle yes :exports code
(def combine-loc #'combine-loc-hjl)

#+end_src
#+latex: \end{listing}

** Lazy evaluation

As pointed out in \cite{imprecise-exceptions}, the addition of
exception handling to a lazy language can cause  increased strictness
by testing a function argument for errors when it's passed rather than
when it is used.  It is important that our wrap mechanism should not
cause unwarranted evaluation of lazy sequences. 




** Post conditions and exceptions
The post condition handling we have considered so far is limited to
the case of a normal return from the function.  As we have seen,
Clojure integrates tightly with Java and can throw Java exceptions or
call Java code which in turn throws an exception.  We would like to be
able to impose post condition contracts on this alternative exit.


** Clojure and object oriented programming 

Clojure supports two separate approaches to object oriented
programming.  Since the 1.0 release there has been support for CLOS
style generic methods; a method is declared as generic and then
implementations are provided for different argument types.  This
naturally provides support for multimethods: implementations are
chosen based on the type of all, not just one, of their arguments.


More recent versions of Clojure also support protocols.  These are a
named set of named methods, effectively an interface definition.  A
type then defines which protocols it implements.  It is this latter
approach which we will consider.

As there is no implementation inheritance, we can limit our contracts
to just applying to the definition of the protocol.  A case could be
made for supporting Liskov Substituion, allowing the protocol
implementation to strengthen the post conditions or weaken the
pre conditions.  From a pragmatic view point, the author feels that
this would just lead to increased difficulties in usage.  Though a
programmer should adhere to the defined protocol contract, if in
practice a weaker contract were implemented it is possible that the
observed behaviour would be assumed to be the documented interface and
so changing implementations could lead to unexpected contract
violations .

* A worked example

My day job is to develop software that forms the infrastructure for a
video conferencing deployment - effectively a telephone exchange for
video conferencing.  In order to test this we use a number of video
endpoints (analogous to a telephone) to place calls in to the system.
Interoperability between our equipment and the various endpoint
manufacturers is an important requirement so we test using a range of
endpoints.

The endpoints all nominally speak the same standardised line side
protocols, SIP \cite{sip} and H.323\cite{h323}, to the infrastructure
equipment.  They also provide APIs to allow automation of call setup
and tear down as well as status reporting. These APIs vary widely, not
only between manufacturers but also between product lines or even
software releases from a single manufacturer.

We desire to produce a framework which will provide basic third party
call control for an abstract endpoint type. The framework can then be
used in the interop test framework for the product under development.
This will require the ability to set up; tear down and answer calls.
Basic state querying will also be required: is the endpoint in a call
or not.  This is a simplified approach for the purposes of this
dissertation - our current test system is significantly more involved,
checking audio and video codec selection call quality and a number of
other areas.  As new endpoint types are acquired in the test lab
device specific plugin functions can be written.  These may be passed
in to function calls in the abstract framework for later invocation,
this adding support for the new device to the interop test framework.
This provides a functional programming analogue for inheritance in
object oriented programming.

As the plugin functions will be written over a period of time by a
variety of people it is important that the required interface to the
abstract call control framework is well defined.  This requirement for
interface definition for later users shows an important distinction
between the role of unit tests for the abstract framework and
contracts placed upon it.  Whilst a unit test framework can
demonstrate that the abstract framework functions according to its
specification it places no constraint on the later writer of a
function supporting a new device.  The test framework can provide
additional documentation of the intended behaviour and as such is
valuable, though only if the plugin writer pays attention to said
documentation.

By providing a contract on the functions taking plugins as a parameter
we provide not only documentation as to expected plugin arguments and
return values, but also enforcement of that expectation.



Looking first at the call setup request: we want to request a
particular endpoint, identified by IP address, to call a particular
destination as identified by a SIP URI; something that looks like an
email address and performs a similar identifying role in video
communications.  Call set up requests are not the same as successful
call establishment.  At the end of the request we know whether or not
the endpoint will honour the set up attempt, but not whether or not it
will be successful.  The request function can therefore signal whether
an endpoint was communicated with (is their an active endpoint at the given
IP address?) and whether or not the request will be honoured
(protocol error? already in a call?).  We will represent this set of
possible return values by the set of keywords
={:not-found :ok :error}=.

We now have the basis of a contract that the framework can place on
plugin functions.  The plugin should take two parameters, one of
which is an IP address, the other a SIP URI.  It should return one of
the given values.  We will therefore require predicates to ascertain
the validity of the contract.


#+latex: \begin{listing}[H]
#+latex: \caption{Example contract definitions} 
#+begin_src clojure :tangle yes :exports code
(import sun.net.util.IPAddressUtil)
(defn ip-address? [s]
  "True if s is a plausible string representation of an
  IPv4 address"
  (and
   (string? s)
   (IPAddressUtil/isIPv4LiteralAddress s))) 

(defn sip-uri? [s]
  "True if s is a plausible SIP URI.  This is a very weak
  implementation, merely checking for the presence of @, a
  real version should consider using javax.sip.address"
  (and
   (string? s)
   (substring? "@" s)))

(defn call-setup-request-result? [k]
  "True if k is a valid response to a call setup request"
  (and
   (keyword? k)
   (k (set [:not-found :ok :error]))))
#+end_src
#+latex: \end{listing}





We now need to provide the abstract call setup request function. Two
possible implementations come to mind: either take a map of endpoints
and setup functions as an arguments, or refer to a global value. In
keeping with Clojure's functional nature we choose the former. Our
abstract functions, of which =call-setup-request= is the first, will
therefore take a map of ={type, function} and an the endpoint type as
their first arguments.  The author of a plugin will be required to
register his function in that map, using our registration function.

#+latex: \begin{listing}[H]
#+latex: \caption{} 
#+begin_src clojure :tangle yes :exports code
(def concrete-setup-request (ref {}))

(defn- add-setup-request-impl [type fn-impl]
  (dosync (alter concrete-setup-request conj  {type fn-impl})))


(defn call-setup-request [type endpoint uri]
  (let [plugin-fn (type (deref concrete-setup-request))]
    (plugin-fn endpoint uri)))
#+end_src
#+latex: \end{listing}
TODO Fully functional call-setup-request


At this point we have no control over the implementation of the
functions stored in =concrete-setup-request= beyond the moral pressure
of documentation.  We wish to be able to place a contract on those
functions passed to =add-setup-request-impl=.  

From knowledge of the implementation of =call-setup-request=, we know
that the =type= argument will be invoked as a function call on a map.
This usage is satisfied by either a function or a keyword.  Though we
expect a keyword to be used, unnecessary restrictions are to be
avoided so we endeavour to include both possibilities.  The =fn=
parameter should take two arguments: a IPv4 address and a SIP URI.  We
have already considered predicates for the ranges of those two
arguments but are in danger of missing an assumption on the arity
=fn=.  Determining the arity of a function in Clojure is not easy.
Whilst functions declared through use of the =defn= macro contain a
metadata item =:arglists= which, as implied by the name, provides a
list of the arguments to the function, this does not provide a
universal solution as lambda functions, defined with =fn=, do not
contain this meta-data item.  We will therefore have to ignore the
arity of =fn-impl=, relying on a run time exception being thrown
should it not match the two argument requirement.

We therefore define a contractual version of =assoc=,
=add-setup-request-impl-c=.  It is interesting to note that, because
of our modular approach to adding contracts to functions, we can apply
contracts to =assoc=, a pre-existing part of the Clojure core library.
A possible disadvantage is that, as we are dealing with a standard
Clojure data type, a map, it would be easy for a developer to
inadvertently bypass our contract wrapping functions and call =assoc=
directly.  Perhaps it would be beneficial to add meta data to the map
entries, marking them as contracted, and checking for the presence of
that meta data in the invocation.  If this is done it will require
malice, rather than mistake, to bypass the contract checks.


=add-setup-request-impl-c= takes three arguments.  The map, the key
into the map of call setup functions, and the setup function
implementation.  We wish to place a contract of =callable?= on the
second; the parameter must form part of a valid sexpr when appearing as
the first element of a list.  The third argument must be a function,
of assumed arity 2, taking both an IPv4 address and a SIP URI,
returning a =code-setup-request-result=.

#+latex: \begin{listing}[H]
#+latex: \caption{} 
#+begin_src clojure :tangle yes :exports code
(defn callable? [f]
  (or
   (keyword? f)
   (function? f)))


(def setup-request-contract
  (make-contract-1
   [ip-address? sip-uri?]
   call-setup-request-result?))

(attach-contracts add-setup-request-impl-c 
                  add-setup-request-impl
                  [[callable?] setup-request-contract])

#+End_src
#+latex: \end{listing}


We can now consider concrete implementations of setup functions.
=hdx-setup= represents a device specific call set up function; in
this case intended to support Polycom's HDX series of endpoints.
=faulty-setup-request= represents a programmer failing to comply with
the specified contract on setup function implementations.

#+latex: \begin{listing}[H]
#+latex: \caption{} 
#+begin_src clojure :tangle yes :exports code

(defn hdx-setup [ip-address uri]
  ;; Product specific code omitted
  :ok)

(defn faulty-setup-request [ip-address uri]
  ;; An incorrectly implemented version, returning an invalid value
  0)

(deftest setup-request-test
  (add-setup-request-impl-c :hdx hdx-setup)
  (is (thrown-with-msg? java.lang.Exception #"Pre"
        (call-setup-request :hdx
                            "invalid-address"
                            "me@example.com")))
  
  (is (thrown-with-msg? java.lang.Exception #"Pre"
        (call-setup-request :hdx
                            "192.168.10.1"
                            "invalid-uri")))
  (is (= :ok
         (call-setup-request :hdx
                             "192.168.10.1"
                             "me@example.com" )))
  
  (add-setup-request-impl-c :faulty faulty-setup-request)
  (is (thrown-with-msg? java.lang.Exception #"Post"
        (call-setup-request :faulty
                            "192.168.10.1"
                            "me@example.com"))))


#+End_src
#+latex: \end{listing}

As can be seen from the test suite, should the concrete implementation
be invoked with invalid arguments, a pre condition violation is
indicated, exonerating the plugin developer.  In the case of
=faulty-setup-request=, a post condition is indicated, blaming teh
developer of the plugin for the error.




For a simple call test we wish to place a call to an alias which,
barring product bugs, should be answered within 5 seconds.  We
therefore combine the call setup and status query in a blocking
function which will return on successful call setup, call setup
failure or failure to establish a call within the given time limit.
This takes the two device specific functions as arguments.

#+BEGIN_SRC clojure
;; setup-fn takes an valid SIP URI and returns {:ok,:setup-failed}
;; established-fn? returns {true, nil}
;; alias is a SIP URI
(defn blocking-setup [setup-fn, established-fn?, alias]
  (setup-fn alias)
  (established-fn? 5))



(defn call-setup-hdx
  "Place a call setup attempt from the HDX at
   `endpoint-ip' to the SIP URI `alias'"
   [endpoint-ip alias]
  ;; code omitted
  )


(defn call-established-hdx? 
  "Waits up to `timeout' to see if the HDX endpoint
  at `endpoint-ip' is in a call"
  [endpoint-ip timeout]
  ;; code omitted
  )

#+END_SRC    
 
We wish to allow the independent development of support for new
endpoint types, but also need to ensure that the interface software
developed for those new endpoints conforms to the needs of our test
harness.  Whilst specifying the requirements in the test harness
documentation ought to suffice, experience has shown that
documentaion is often not consulted and even if checked, constraints
not necessarily complied with.  We will therefore establish contracts
on our test harness software which place obligations on the functions
passed to it.
* Discussion

** On learning Clojure

One of the stated goals of this project was to learn more about
Clojure as a language.  The two different approaches to applying
contracts to functions; the monolithic and modular approaches of
\ref{codegen} arose through my initial unfamiliarity with the
language.  My first attempts at writing a macro to wrap function
arguments failed with a number of errors related to symbol resolution
and inadvertent variable capture or anaphora.  I had not fully
appreciated that in moving to Clojure I had not just to pick up a new
language syntax, but also a new development paradigm.  The majority of
my previous development work has been in C++ so the change to dynamic
typing was new.  I was in danger of adding multiple type checking
assertions to function arguments, going against the grain of Clojure
development. Rather than stepping back and finding a simpler approach
I began trying to resolve each immediate error and soon became
enmeshed in a hopelessly complicated code.  Deciding that a modular
solution could not be produced in Clojure, I came up with the
monolithic solution presented in Listing \ref{}.

As the dissertation progressed my familiarity with the language, and
in particular macros, increased.  Prompted by a question from my
tutor, Dr Hinze, I revisited the modular solution and this time was
able to achieve a more satisfactory solution --- the =attach-contracts=
macro of Listing \ref{ }. 

Clojure's compile time macros, though very powerful, proved confusing
at times.  This was one of the difficulties which led to my initial
monolithic approach.  On other occasions I avoided going down the
macro root. The arity checking code of \ref{ho-wrap} could be written
more flexibly as a macro rather than having explicit branches for
arity 0,1,2.  I was concerned that, though more flexible, such an
approach would obscure the meaning of the code, both to the reader
and to me. This question of how sophisticated to make one's code seems
to be a recurring one: I've had many conversations over the
desirability or otherwise of using some C++ template features in
production code.

The worked example of section \ref{} provided a number of insights
into the modular framework.  It was very satisfying to be able to
attach contracts to normal Clojure functions as in the use of
=assoc== in Listing \ref{}.  The ability to apply Design by Contract
retrospectively to existing functions vastly increases the attraction
of such a framework.  If every  function had to be written with
contracts in mind, as in the initial monolithic framework, the
housekeeping overhead would be unacceptable.

Less satisfying is the fragility of the interface to
=attach-contracts=.  I found myself frequently having to revisit code
I had written using this function in order to correct the contract
parameter list: proof that the current design is not intuitive.  More
concerning, an inadvertent use of a ='= character in \ref{}:

=(add-setup-request-impl-c :hdx 'hdx-setup)=

instead of

=(add-setup-request-impl-c :hdx hdx-setup)=

proved a frustrating bug to track down: calls to =call-setup-request=
were simply returning the last argument passed in.  The problem was
eventually tracked down to the expansion in =ho-wrap= to 
=('hdx-setup arg1 arg2)= rather than =(hdx-setup arg1 arg2)=.  The
quote prevents the evaluation of =hdx-setup=, hence it is not invoked
as a function.  The return value of such a form is simply the last
element: =arg2=, hence my bug.  Having discovered this I was tempted
to add a number of assertions checking the arguments passed in to
=ho-wrap= but having already been burnt by going against the grain of
the language I have resisted this. I believe the idiomatic solution
to this is the use of unit tests, which initially demonstrated the
problem, and a better knowledge of the language to make root cause
determination quicker.  Coming from a background of static typed
languages, this still feels somewhat fragile.


\cite{citeulike:661450} provides the following table to indicate where
contracts fit naturally into the checking spectrum.

|                    | static checking      | dynamic checking      |
|--------------------+----------------------+-----------------------|
| simple properties  | static type checking  | dynamic type checking |
| complex properties | theorem proving      | contract checking     |

This is in accordance with my findings. A lot of the first order
contracts I have implemented have been simple type and range checks,
something which could be under taken by a suitable static type
system.  The checks on higher order functions were not so amenable to
static checking.
 



** Design by Contract and Test Driven Development

There is fair degree of overlap between the role of assertions and
Unit Tests.  This has led to some advocates of Agile Development
methodologies \cite{c2dbc} arguing that assertions are not useful as their role
is subsumed by the presence of Unit Tests.  As Design by Contract is
built upon the use of assertions, this would argue that Design by
Contracts is also not useful.  

A key difference between the role of the two is that assertions are
declarative, stating how the world should be; whilst unit tests are
imperative, describing what should happen when a particular stimulus
is given.  Assertions therefore provide a wide description of the
desired state, but - in the absence of static checking - this
description is only compared with the actuality when code is
executed.  Whilst this could be in production use on a customer's
site it is surely better under controlled conditions in the
development team. Unit testing provides a complementary role,
with the tests describing the conditions under which the system is
known to function correctly.  In this case "function correctly" may
be defined as "function in accordance with its contracts".

One of the key aspects of Design by Contract is described in the
first word: "Design".  In specifying a contract for a function it is
necessary to think deeply about the requirements of the specification
of the function and try to separate those from artefacts of its
implementation.  It is this specification which should then be
captured in the contract.  Unit testing has an analogous thought
process in Test Driven Development
(TDD)\cite{tdd}. When practising
TDD the unit tests are written before the implementation code.  This
change in ordering from the more traditional "design, code, test"
waterfall highlights the question of how the function will be invoked
before considering concerns of how to implement it.  A good unit test
also investigate the functions behaviour for various edge conditions
but, by its imperative nature, is unlikely to be exhaustive for all
but the most trivial functions.

Design by Contract and Test Driven Development provide two
complementary approaches to improving the quality of software.


** Comparison with other Design by Contract frameworks


Many Design by Contract frameworks \cite{racket}, \cite{oosc}
provide contract enforcement only at the boundaries of a module.  

If we consider Racket, a member of the Scheme/Lisp family, it features
a sophisticated and modular contract mechanism. This is unsurprising
as it comes from the authors of \cite{hof}. Examining their contract
implementation \cite{racket-src} we see that it makes heavy use of
make-provide syntax transformers \cite{racket-doc-transform}. These
are run when a module is loaded and allow the transformation of forms
within the provide expression. This low level language implementation
allows Racket to follow Eiffel and implement contract verification
only at module boundaries. Ignoring arguments about run time speed,
the ability for a call within a module to violate a contract can be
useful, particularly where invariants are concerned.

Replicating the sophisticated Racket macro system in Clojure is beyond
the scope of this dissertation.  Our approach to enforcing contracts
only at module boundaries is based on Clojure's concept of private
functions.  By defining non-contractual functions as private to a name
space and their contractual versions as public a similar effect may be
achieved.  Whilst privacy enforcement is not possible in Clojure
\cite{maier}, this provides a modicum of protection against mistaken
usage.




** The current state of Design by Contract 

As we have seen, Clojure has basic support for pre and post condition
checking, and there are some enthusiastic blogs \cite{onclojure-blog},
\cite{objectcommando-blog} commenting on the possibilities. But
despite this, current practice does not extend to significant use of
these techniques. Examination of typical libraries reveals little
usage: =clojure-contrib= currently (Version 1.2) has one =:pre= check
in 27,000 lines of code. In contrast there are 41 asserts.

A similar picture emerges for the use of validator functions, there
are no calls to =set-validator!= in =clojure-contrib=.  Refs are in
use though: the transaction functions used to alter them are called
several times:

| mutating function | frequency |
| =ref-set=         |        22 |
| =alter=           |        11 |
| =commute=         |         7 |

To endeavour to promote a more complicated contract checking mechanism
on a community which has not adopted first order contract checking is
unlikely to be worthwhile.  So why has the Clojure, and wider,
community not adopted Design by Contract?  Whilst I am unaware of any
formal studies into this, a widely heard response \cite{why-dont},
\cite{irc-clojure} combine the difficulty of identifying the relevant
contracts whilst creating a function and the difficulty in then reusing
or refactoring this constrained code. 

An extreme example of the difficulty of reuse is the Ariane 5 rocket
failure.  The software was based on that used in the Ariane 4
programme.  Unfortunately the rocket hardware had improved to such an
extent that a previously impossible flight trajectory could now be
achieved.  This resulted in an integer overflow, which was not
protected as after inspection with the original hardware in mind, it
was determined that the situation could never arise.  In order to
preserve CPU cycles, checks were limited to those cases where it was
deemed possible for the errors to occur.

The enquiry into the failure recommended\cite{ariane}
 
"R12 Give the justification documents the same attention as
code. Improve the technique for keeping code and its justifications
consistent."

The idea being that, on reuse of the Ariane 4 code, the assumptions
and justifications could be readily seen.  But the problem of keeping
documentation and code in synchronisation is a long known one, indeed
one of the drivers behind Eiffel's short form.  So could we not
document our assumptions in the code as contracts and then,
independently, determine whether or not to enforce those contracts?



* Conclusions

To Be Completed

\pagebreak
\bibliographystyle{alpha}
\bibliography{dbc}

* Notes :noexport:


make-contract-1 is actually making a HIGHER ORDER contract.  First order
contracts are flat assertions.

what do we do about functions that take more than one parameter?
Need to work out some use of =partial= to give us what we need.
Current post condition check is an ugly special case.

Same problem applies to function args that are fns of more than one
arg.  This must be symmetric surely.





** Existing work

There's a contracts library at http://www.fogus.me/fun/trammel/docs.html

**  Runtime vs Compile time contract assignment



Is there any benefit in using hooks to give the ability to set contracts at run time?












MSFT .NET http://research.microsoft.com/en-us/projects/contracts/






Code Contracts User Manual
Microsoft Corporation January 8, 2012




Inability to make contracts plugin to function.  Flies againdt
modularity argument of "Why Functional Programming matters", Hughes 1990




#clojure: <2012-08-03 Fri> 
<ohpauleez> 1.)
People move code around like clay - they don't quite think as
	    far ahead or careful as someone like Rich might
<ohpauleez> it's hard to come up with the constraints of a system that you
	    yourself aren't even sure about  [16:19]
<ohpauleez> 2.) Creating contraints on domain input and output takes practice,
	    just like writing good tests
<ohpauleez> BUT
<ohpauleez> you end up capturing these domains in your tests anyway, you might
	    as well enforce them and program defensively
<ohpauleez> Programming to an interface instead of an implementation helps to
	    avoid pointless dependencies between calling pieces of code

