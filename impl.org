#+TITLE:     Design by Contract in Clojure: implementation
#+AUTHOR:    Giles Chamberlin
#+OPTIONS:   H:2 num:t toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+LaTeX_CLASS_OPTIONS: [a4paper, 12pt] 
#+LATEX_HEADER: \usepackage{parskip} \usepackage{times} \usepackage{minted} \usepackage{cite}
#+LATEX_HEADER: \usepackage{hyperref} 

#+LaTeX_HEADER: \usemintedstyle{bw}
#+LaTeX_HEADER: \newminted{common-lisp}{fontsize=\footnotesize,linenos}

\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black,
    pdfauthor=Giles Chamberlin,
    pdfsubject=Draft chapter for M.Sc. dissertation,
    pdftitle=Design by contract in Clojure
}

\listoflistings

* A Clojure implementation

Our initial implementation is based on that described by Findelr and
Fellisen: we create a function, =wrap= which is used to wrap each
parameter in a function call.  Should the parameter be first-order,
=wrap= will trigger an immediate assertion check.  High order
parameters, function which will be used later, are replaced a new
function which wraps the original in a contract checker:

#+srcname: preamble
#+begin_src clojure :exports none
(ns dbc.core
  (:use clojure.test clojure.template clojure.contrib.condition))


;; Commentary
;; Contracts consist of two parts: pre and post
;; conditions, stored in the contract map as dom and rnf respectively.
;;
;; All contracts pertain to the arguments to this function so if the
;; argument is a high order function, then the contract states: "takes
;; a function which returns positive numbers" or some such.

;; So how do we describe that contract?

;; "takes a positive number": (pos ?)
;; "takes a function which returns a positive number": ?


(defn make-contract [pre post]
  "Returns a contract with dom and rng set to pre and post
respectively."
  {:dom pre :rng post})

(defn dom [contract]
  (:dom contract))

(defn rng [contract]
  (:rng contract))

(declare flat?)

(defn lenient [_]
  true)

(defn strict [_]
  false)

(defn gt0 [x]
  (and
   (number? x)
   (pos? x)))


(deftest contract-construction
  (testing "Flat predicate"
    (is (flat? :foo))
    (is (not (flat? (make-contract :foo :bar)))))
  (testing "Contract construction"
    (is (= 2 (count (make-contract :foo :bar))))
    (is ((dom (make-contract lenient lenient)) 42))))





(defn pred [contract value]
  "CONTRACT must be a function which accepts a single value to check."
  (contract value))

  (declare fo-wrap ho-wrap)

; TODO look at using clojure-contrib.condition/raise here
(defn contract-error [position]
  (throw (Exception. (str "Contract failed: " position))))


#+end_src



#     Mutual recursion, as in ho-warp and wrap, probably ought to
#     use trampolining:
#     http://groups.google.com/group/clojure/msg/3addf875319c5c10
    

    

#+latex: \begin{listing}[H]
#+LATEX: \caption{Clojure implementation of \texttt{wrap}}\label{wrap}
#+srcname: wrap
#+begin_src clojure
  (defn wrap [contract value p n]
    (if (flat? contract)
      (fo-wrap contract value p n)
      (ho-wrap contract value p n)))
  
  (defn fo-wrap  [contract value p n]
    (if (pred contract value)
      value
      (contract-error p)))
  
  (defn ho-wrap [ct x p n]
    (let [d (dom ct)
          r (rng ct)]
      (fn [y] (wrap r
                    (x (wrap d y n p))
                    p
                    n))))
  
  (defn flat? [x]
    (not (map? x)))
#+end_src
#+latex: \end{listing}

A simple high order example of the use of =wrap= is based on
F&F. Consider a function =save= which saves a function and =use= which
later calls the saved function, activating its contract:










** Code generation
Although logically correct, manually wrapping each occurrence of a
parameter in calls to =wrap= is tedious work, the sort of thing
computers were intended to relieve us from.  Clojure, like other
lisps, has a sophisticated macro system which can be used to
automatically generate this code.  

#+begin_listing
#+LATEX: \caption{Initial contract macro}\label{defcontract1}
#+srcname: defcontract1
#+begin_src clojure
(defmacro defcontract-1 [fn-name as cs body]
  (assert (vector? as))
  (assert (vector? cs))
  (let [subst (zipmap as (map (fn [a c] `(wrap ~c ~a)) as cs)) ] 
       `(defn ~fn-name ~as
	  ~(clojure.walk/postwalk-replace subst body))))
#+end_src
#+end_listing


Examining what's happening in Figure \ref{defcontract1}: the =let=
line creates a map of substitutions for every function argument (the
vector =as=), calling =wrap= with the corresponding member of the
contract array =cs=. The macro then emits the function definition,
rendering the back-quoted form verbatim and substituting \tilde
prefixed expressions by their evaluated result.  The function
=postwalk-replace= will replace each member of =as= with the
corresponding wrapped call in =subst=.

The overall result of this macro is to create a function definition
with every use of an argument wrapped in a call to the =wrap= function
of Figure \ref{wrap}. 

** Separation of concerns
The macro defined in Figure \ref{defcontract1} successfully automates
the process of wrapping function parameters in contract checking
code. Unfortunately the resulting code is monolithic; conflating
function implementation and contract.  When used for functions like
the =sqrt= example this is not too disastrous: the contract is a
result of the underlying mathematics of the implementation.  But if we
need similar contracts for other functions reuse will be limited.  In
some cases contracts will be used to impose business rules on a
function, rather than implementation artefacts.  In that case we may
want to reuse the function implementation with a different contract in
an alternative environment.

Ideally a contract should just be an aspect of the function, along
with its implementation.  Aspect Oriented Programming has been used
\cite{aopdbc} to implement Design by Contract in AspectJ.  We're
seeking to develop a similar approach where the contract and
underlying function implementation can be specified separately and
combined at will.

Following the method used for first order contracts in \cite{joy} we
restate the problem to provide a contract observing function which
calls an implementation function.  

#+BEGIN_listing
#+LATEX: \caption{The caption.}\label{fig:src_blk}
#+begin_src clojure
;; TODO provide an example of the above
#+end_src
#+END_listing


The boiler plate code for this recurring pattern can be abstracted in
to another macro:

#+begin_src clojure
;; macro to generate the above
#+end_src



* Notes :noexport:

From irc

 http://richhickey.github.com/clojure/clojure.template-api.html

`(let ~(vector 'a 1) ~'a))

#+begin_src clojure
(defcontract sqrt [n '(> 0)])


  (defn sqrt-contract [a]

    
    (let [a (wrap a a') b (wrap b b')]
      (foo' a' b')))
  
#+end_src


Note that if parameter is never used the contract is never checked!

** lazy sequences?

** global variables


** Existing work

There's a contracts library at http://www.fogus.me/fun/trammel/docs.html


#+srcname: full
#+begin_src clojure :tangle literate :exports none :noweb yes
<<preamble>>
<<wrap>>
<<defcontract1>>
#+end_src


